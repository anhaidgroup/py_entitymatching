

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Blocking &#8212; py_entitymatching 0.3.2 documentation</title>
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Debugging Blocker Output" href="debugging_blocker_output.html" />
    <link rel="prev" title="Data Exploration" href="data_exploration.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="debugging_blocker_output.html" title="Debugging Blocker Output"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="data_exploration.html" title="Data Exploration"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">py_entitymatching 0.3.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="actual_commands.html" accesskey="U">Commands in py_entitymatching</a> &#187;</li> 
      </ul>
    </div>
<div class="content-wrapper">
    <div class="content">
        <div class="document">
            <div class="sphinxsidebar">
                <h3>Table Of Contents</h3>
                <p class="caption"><span class="caption-text">How To Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../how_to_guide.html">How to Guide To Do Entity Matching</a></li>
</ul>
<p class="caption"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../whatisnew.html">What is New?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview of Supported EM Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datastructures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../steps_supp_em_workflows.html">Steps of Supported EM Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc.html">Miscellaneous</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview of Command Organization</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="actual_commands.html">Commands in py_entitymatching</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="reading_and_writing_data.html">Reading and Writing Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="loading_and_saving_objects.html">Loading and Saving Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="handling_metadata.html">Handling Metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="downsampling.html">Downsampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="data_exploration.html">Data Exploration</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Blocking</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging_blocker_output.html">Debugging Blocker Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="combining_blocker_outputs.html">Combining Blocker Outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="sampling.html">Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="labeling.html">Labeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="handling_features.html">Handling Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="matching.html">Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging_matcher.html">Debugging Matcher</a></li>
<li class="toctree-l2"><a class="reference internal" href="triggers.html">Triggers</a></li>
<li class="toctree-l2"><a class="reference internal" href="evaluating_the_matching_output.html">Evaluating the Matching Output</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="actual_commands.html#experimental-commands">Experimental Commands</a></li>
</ul>

                <h3 style="margin-top: 1.5em;">Search</h3>

                <form class="search" action="../../search.html" method="get">
                    <input type="text" name="q" size="18"/>
                    <input type="submit" value="Go"/>
                    <input type="hidden" name="check_keywords" value="yes"/>
                    <input type="hidden" name="area" value="default"/>
                </form>
                <p class="searchtip" style="font-size: 90%">
                    Enter search terms or a module, class or function name.
                </p>

            </div>
             
            <div class="documentwrapper">
                <div class="bodywrapper">
                    <div class="body">
                        
  <div class="section" id="blocking">
<h1>Blocking<a class="headerlink" href="#blocking" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="py_entitymatching.AttrEquivalenceBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">AttrEquivalenceBlocker</code><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks based on the equivalence of attribute values.</p>
<dl class="method">
<dt id="py_entitymatching.AttrEquivalenceBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param">candset</em>, <em class="sig-param">l_block_attr</em>, <em class="sig-param">r_block_attr</em>, <em class="sig-param">allow_missing=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">show_progress=True</em>, <em class="sig-param">n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks an input candidate set of tuple pairs based on attribute equivalence.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs
such that the value of attribute l_block_attr of the left tuple in a
tuple pair exactly matches the value of attribute r_block_attr of the
right tuple in the tuple pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left table.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right table.</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple pair with missing value in either
blocking attribute will be retained in the
output candidate set.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Execute blocking using multiple cores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.AttrEquivalenceBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param">ltable</em>, <em class="sig-param">rtable</em>, <em class="sig-param">l_block_attr</em>, <em class="sig-param">r_block_attr</em>, <em class="sig-param">l_output_attrs=None</em>, <em class="sig-param">r_output_attrs=None</em>, <em class="sig-param">l_output_prefix='ltable_'</em>, <em class="sig-param">r_output_prefix='rtable_'</em>, <em class="sig-param">allow_missing=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks two tables based on attribute equivalence.</p>
<p>Conceptually, this will check <cite>l_block_attr=r_block_attr</cite> for each tuple
pair from the Cartesian product of tables <cite>ltable</cite> and <cite>rtable</cite>. It outputs a
Pandas dataframe object with tuple pairs that satisfy the equality condition.
The dataframe will include attributes ‘_id’, key attribute from
ltable, key attributes from rtable, followed by lists <cite>l_output_attrs</cite> and
<cite>r_output_attrs</cite> if they are specified. Each of these output and key attributes will be
prefixed with given <cite>l_output_prefix</cite> and <cite>r_output_prefix</cite>. If <cite>allow_missing</cite> is set
to <cite>True</cite> then all tuple pairs with missing value in at least one of the tuples will be
included in the output dataframe.
Further, this will update the following metadata in the catalog for the output table:
(1) key, (2) ltable, (3) rtable, (4) fk_ltable, and (5) fk_rtable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left table.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right table.</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.AttrEquivalenceBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param">ltuple</em>, <em class="sig-param">rtuple</em>, <em class="sig-param">l_block_attr</em>, <em class="sig-param">r_block_attr</em>, <em class="sig-param">allow_missing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on attribute equivalence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left tuple.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right tuple.</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether a tuple pair
with missing value in at least one of the
blocking attributes should be blocked
(defaults to False). If this flag is set
to True, the pair will be kept if either
ltuple has missing value in l_block_attr
or rtuple has missing value in r_block_attr
or both.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair is blocked, i.e., the values
of l_block_attr in ltuple and r_block_attr in rtuple are different
(boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.OverlapBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">OverlapBlocker</code><a class="headerlink" href="#py_entitymatching.OverlapBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks  based on the overlap of token sets of attribute values.</p>
<dl class="method">
<dt id="py_entitymatching.OverlapBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param">candset</em>, <em class="sig-param">l_overlap_attr</em>, <em class="sig-param">r_overlap_attr</em>, <em class="sig-param">rem_stop_words=False</em>, <em class="sig-param">q_val=None</em>, <em class="sig-param">word_level=True</em>, <em class="sig-param">overlap_size=1</em>, <em class="sig-param">allow_missing=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">show_progress=True</em>, <em class="sig-param">n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.OverlapBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Blocks an input candidate set of tuple pairs based on the overlap</dt><dd><p>of token sets of attribute values.</p>
</dd>
</dl>
<p>Finds tuple pairs from an input candidate set of tuple pairs such that
the overlap between (a) the set of tokens obtained by tokenizing the
value of attribute l_overlap_attr of the left tuple in a tuple pair,
and (b) the set of tokens obtained by tokenizing the value of
attribute r_overlap_attr of the right tuple in the tuple pair,
is above a certain threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left table.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right table.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed
from the token sets of the overlap
attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – The value of q to use if the overlap attributes values
are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words
(i.e, using whitespace as delimiter)
(defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must overlap
(defaults to 1).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple pair with missing value in either
blocking attribute will be retained in the
output candidate set.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – <p>A flag to indicate whether the debug information</p>
<p>should be logged (defaults to False).</p>
</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>q_val</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>word_level</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>overlap_size</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not in the ltable
    columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to a valid value and
    <cite>word_level</cite> is set to True.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to None and
    <cite>word_level</cite> is set to False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Execute blocking using multiple cores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># Use q-gram tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">q_val</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.OverlapBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param">ltable</em>, <em class="sig-param">rtable</em>, <em class="sig-param">l_overlap_attr</em>, <em class="sig-param">r_overlap_attr</em>, <em class="sig-param">rem_stop_words=False</em>, <em class="sig-param">q_val=None</em>, <em class="sig-param">word_level=True</em>, <em class="sig-param">overlap_size=1</em>, <em class="sig-param">l_output_attrs=None</em>, <em class="sig-param">r_output_attrs=None</em>, <em class="sig-param">l_output_prefix='ltable_'</em>, <em class="sig-param">r_output_prefix='rtable_'</em>, <em class="sig-param">allow_missing=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">show_progress=True</em>, <em class="sig-param">n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.OverlapBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Blocks two tables based on the overlap of token sets of attribute</dt><dd><p>values.</p>
</dd>
</dl>
<p>Finds tuple pairs from left and right tables such that the overlap
between (a) the set of tokens obtained by tokenizing the value of
attribute l_overlap_attr of a tuple from the left table, and (b) the
set of tokens obtained by tokenizing the value of attribute
r_overlap_attr of a tuple from the right table, is above a certain
threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left table.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right table.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed from the token sets of the
overlap attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – The value of q to use if the overlap attributes
values are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words (i.e, using whitespace
as delimiter) (defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must
overlap (defaults to 1).</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the output candidate set (defaults
to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the output candidate set  (defaults
to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_overlap_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>q_val</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>word_level</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>overlap_size</cite> is not of type int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_overlap_attr</cite> is not in the ltable
    columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> are not in the rtable.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to a valid value and
    <cite>word_level</cite> is set to True.</p></li>
<li><p><strong>SyntaxError</strong> – If <cite>q_val</cite> is set to None and
    <cite>word_level</cite> is set to False.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="go"># Use word-level tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># Use q-gram tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">q_val</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go"># Include all possible missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Use all the cores in the machine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.OverlapBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param">ltuple</em>, <em class="sig-param">rtuple</em>, <em class="sig-param">l_overlap_attr</em>, <em class="sig-param">r_overlap_attr</em>, <em class="sig-param">rem_stop_words=False</em>, <em class="sig-param">q_val=None</em>, <em class="sig-param">word_level=True</em>, <em class="sig-param">overlap_size=1</em>, <em class="sig-param">allow_missing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.OverlapBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Blocks a tuple pair based on the overlap of token sets of attribute</dt><dd><p>values.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</p></li>
<li><p><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left tuple.</p></li>
<li><p><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right tuple.</p></li>
<li><p><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed
from the token sets of the overlap
attribute values (defaults to False).</p></li>
<li><p><strong>q_val</strong> (<em>int</em>) – A value of q to use if the overlap attributes values
are to be tokenized as qgrams (defaults to None).</p></li>
<li><p><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words
(i.e, using whitespace as delimiter)
(defaults to True).</p></li>
<li><p><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must overlap
(defaults to 1).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether a tuple pair
with missing value in at least one of the
blocking attributes should be blocked
(defaults to False). If this flag is set
to True, the pair will be kept if either
ltuple has missing value in l_block_attr
or rtuple has missing value in r_block_attr
or both.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair is blocked (boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.RuleBasedBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">RuleBasedBlocker</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks  based on a sequence of blocking rules supplied by the user.</p>
<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.add_rule">
<code class="sig-name descname">add_rule</code><span class="sig-paren">(</span><em class="sig-param">conjunct_list</em>, <em class="sig-param">feature_table=None</em>, <em class="sig-param">rule_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.add_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a rule to the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conjunct_list</strong> (<em>list</em>) – A list of conjuncts specifying the rule.</p></li>
<li><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing all the
features that are being referenced by
the rule (defaults to None). If the
feature_table is not supplied here,
then it must have been specified
during the creation of the rule-based
blocker or using set_feature_table
function. Otherwise an AssertionError
will be raised and the rule will not
be added to the rule-based blocker.</p></li>
<li><p><strong>rule_name</strong> (<em>string</em>) – A string specifying the name of the rule to
be added (defaults to None). If the
rule_name is not specified then a name will
be automatically chosen. If there is already
a rule with the specified rule_name, then
an AssertionError will be raised and the
rule will not be added to the rule-based
blocker.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The name of the rule added (string).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>rule_name</cite> already exists.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>feature_table</cite> is not a valid value
    parameter.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param">candset</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">show_progress=True</em>, <em class="sig-param">n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks an input candidate set of tuple pairs based on a sequence of
blocking rules supplied by the user.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs that
survive the sequence of blocking rules. A tuple pair survives the
sequence of blocking rules if none of the rules in the sequence returns
True for that pair. If any of the rules returns True, then the pair is
blocked (dropped).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information  should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If there are no rules to apply.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># C is the candidate set.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param">ltable</em>, <em class="sig-param">rtable</em>, <em class="sig-param">l_output_attrs=None</em>, <em class="sig-param">r_output_attrs=None</em>, <em class="sig-param">l_output_prefix='ltable_'</em>, <em class="sig-param">r_output_prefix='rtable_'</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">show_progress=True</em>, <em class="sig-param">n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks two tables based on the sequence of rules supplied by the user.</p>
<p>Finds tuple pairs from left and right tables that survive the sequence
of blocking rules. A tuple pair survives the sequence of blocking rules
if none of the rules in the sequence returns True for that pair. If any
of the rules returns True, then the pair is blocked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information  should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived the sequence of
blocking rules (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the input <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the input <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
<li><p><strong>AssertionError</strong> – If there are no rules to apply.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param">ltuple</em>, <em class="sig-param">rtuple</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on a sequence of blocking rules supplied
by the user.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair is blocked by applying the
sequence of blocking rules (boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.delete_rule">
<code class="sig-name descname">delete_rule</code><span class="sig-paren">(</span><em class="sig-param">rule_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.delete_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a rule from the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be deleted.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.get_rule">
<code class="sig-name descname">get_rule</code><span class="sig-paren">(</span><em class="sig-param">rule_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.get_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the function corresponding to a rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A function object corresponding to the specified rule.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">get_rule</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.get_rule_names">
<code class="sig-name descname">get_rule_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.get_rule_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all the rules in the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of names of all the rules in the rule-based blocker (list).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.set_feature_table">
<code class="sig-name descname">set_feature_table</code><span class="sig-paren">(</span><em class="sig-param">feature_table</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.set_feature_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets feature table for the rule-based blocker.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing features.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">set_feature_table</span><span class="p">(</span><span class="n">block_f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.view_rule">
<code class="sig-name descname">view_rule</code><span class="sig-paren">(</span><em class="sig-param">rule_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.view_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the source code of the function corresponding to a rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be viewed.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.BlackBoxBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">BlackBoxBlocker</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks based on a black box function specified by the user.</p>
<dl class="method">
<dt id="py_entitymatching.BlackBoxBlocker.block_candset">
<code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param">candset</em>, <em class="sig-param">verbose=True</em>, <em class="sig-param">show_progress=True</em>, <em class="sig-param">n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks an input candidate set of tuple pairs based on a black box
blocking function specified by the user.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs that
survive the black box function. A tuple pair survives the black box
blocking function if the function returns False for that pair,
otherwise the tuple pair is dropped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether logging should be done
(defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>candset</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># C is an output from block_tables</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.BlackBoxBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param">ltable</em>, <em class="sig-param">rtable</em>, <em class="sig-param">l_output_attrs=None</em>, <em class="sig-param">r_output_attrs=None</em>, <em class="sig-param">l_output_prefix='ltable_'</em>, <em class="sig-param">r_output_prefix='rtable_'</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">show_progress=True</em>, <em class="sig-param">n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks two tables based on a black box blocking function specified
by the user.</p>
<p>Finds tuple pairs from left and right tables that survive the black
box function. A tuple pair survives the black box blocking function if
the function returns False for that pair, otherwise the tuple pair is
dropped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</p></li>
<li><p><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_attrs</cite> is not of type of
    list.</p></li>
<li><p><strong>AssertionError</strong> – If values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>show_progress</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.BlackBoxBlocker.block_tuples">
<code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param">ltuple</em>, <em class="sig-param">rtuple</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on a black box blocking function specified
by the user.</p>
<p>Takes a tuple pair as input, applies the black box blocking function to
it, and returns True (if the intention is to drop the pair) or False
(if the intention is to keep the tuple pair).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltuple</strong> (<em>Series</em>) – input left tuple.</p></li>
<li><p><strong>rtuple</strong> (<em>Series</em>) – input right tuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A status indicating if the tuple pair should be dropped or kept,
based on the black box blocking function (boolean).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># A, B are input tables.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.BlackBoxBlocker.set_black_box_function">
<code class="sig-name descname">set_black_box_function</code><span class="sig-paren">(</span><em class="sig-param">function</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.set_black_box_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets black box function to be used for blocking.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<em>function</em>) – the black box function to be used for blocking .</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.SortedNeighborhoodBlocker">
<em class="property">class </em><code class="sig-prename descclassname">py_entitymatching.</code><code class="sig-name descname">SortedNeighborhoodBlocker</code><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING: THIS IS AN EXPERIMENTAL CLASS. THIS CLASS IS NOT TESTED.
USE AT YOUR OWN RISK.</p>
<p>Blocks based on the sorted neighborhood blocking method</p>
<dl class="method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.block_candset">
<em class="property">static </em><code class="sig-name descname">block_candset</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>block_candset does not apply to sn_blocker, return unimplemented</p>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.block_tables">
<code class="sig-name descname">block_tables</code><span class="sig-paren">(</span><em class="sig-param">ltable</em>, <em class="sig-param">rtable</em>, <em class="sig-param">l_block_attr</em>, <em class="sig-param">r_block_attr</em>, <em class="sig-param">window_size=2</em>, <em class="sig-param">l_output_attrs=None</em>, <em class="sig-param">r_output_attrs=None</em>, <em class="sig-param">l_output_prefix='ltable_'</em>, <em class="sig-param">r_output_prefix='rtable_'</em>, <em class="sig-param">allow_missing=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>WARNING: THIS IS AN EXPERIMENTAL COMMAND. THIS COMMAND IS NOT TESTED.
USE AT YOUR OWN RISK.</p>
<p>Blocks two tables based on sorted neighborhood.</p>
<p>Finds tuple pairs from left and right tables such that when each table
is sorted based upon a blocking attribute, tuple pairs are within a
distance w of each other. The blocking attribute is created prior to calling
this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</p></li>
<li><p><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</p></li>
<li><p><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute for left table.</p></li>
<li><p><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute for right table.</p></li>
<li><p><strong>window_size</strong> (<em>int</em>) – size of sliding window. Defaults to 2</p></li>
<li><p><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</p></li>
<li><p><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</p></li>
<li><p><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</p></li>
<li><p><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</p></li>
<li><p><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>AssertionError</strong> – If <cite>ltable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>rtable</cite> is not of type pandas
    DataFrame.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not of type string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>window_size</cite> is not of type of
    int or if window_size &lt; 2.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>l_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If the values in <cite>r_output_attrs</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_output_prefix</cite> is not of type
    string.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>verbose</cite> is not of type
    boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>allow_missing</cite> is not of type boolean.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>n_jobs</cite> is not of type
    int.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_block_attr</cite> is not in the ltable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_block_attr</cite> is not in the rtable columns.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>l_out_attrs</cite> are not in the ltable.</p></li>
<li><p><strong>AssertionError</strong> – If <cite>r_out_attrs</cite> are not in the rtable.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.block_tuples">
<em class="property">static </em><code class="sig-name descname">block_tuples</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>block_tuples does not apply to sn_blocker, return unimplemented</p>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.validate_block_attrs">
<em class="property">static </em><code class="sig-name descname">validate_block_attrs</code><span class="sig-paren">(</span><em class="sig-param">ltable</em>, <em class="sig-param">rtable</em>, <em class="sig-param">l_block_attr</em>, <em class="sig-param">r_block_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.validate_block_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the blocking attributes</p>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.SortedNeighborhoodBlocker.validate_types_block_attrs">
<em class="property">static </em><code class="sig-name descname">validate_types_block_attrs</code><span class="sig-paren">(</span><em class="sig-param">l_block_attr</em>, <em class="sig-param">r_block_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SortedNeighborhoodBlocker.validate_types_block_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the data types of the blocking attributes</p>
</dd></dl>

</dd></dl>

</div>


                    </div>
                </div>
            </div>

            
            <div class="clearer"></div>
        </div>
    </div>
</div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="debugging_blocker_output.html" title="Debugging Blocker Output"
             >next</a> |</li>
        <li class="right" >
          <a href="data_exploration.html" title="Data Exploration"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">py_entitymatching 0.3.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="actual_commands.html" >Commands in py_entitymatching</a> &#187;</li> 
      </ul>
    </div>
<style type="text/css">
    .scrollToTop {
        text-align: center;
        font-weight: bold;
        position: fixed;
        bottom: 60px;
        right: 40px;
        display: none;
    }
</style>
<a href="#" class="scrollToTop">Scroll To Top</a>
<script type="text/javascript">
$(document).ready(function() {
    //Check to see if the window is top if not then display button
    $(window).scroll(function() {
        if ($(this).scrollTop() > 200) {
            $('.scrollToTop').fadeIn();
        } else {
            $('.scrollToTop').fadeOut();
        }
    });

    //Click event to scroll to top
    $('.scrollToTop').click(function() {
        $('html, body').animate({
            scrollTop: 0
        }, 500);
        return false;
    });
});
</script>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27880019-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>