

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Specifying Blockers and Performing Blocking &mdash; py_entitymatching 0.1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="py_entitymatching 0.1.0 documentation" href="../index.html"/>
        <link rel="up" title="Steps of Supported EM Workflows" href="steps_supp_em_workflows.html"/>
        <link rel="next" title="Creating Features for Blocking" href="create_feats_for_blocking.html"/>
        <link rel="prev" title="Down Sampling" href="down_sampling.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> py_entitymatching
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">How To Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../how_to_guide.html">How to Guide To Do Entity Matching</a></li>
</ul>
<p class="caption"><span class="caption-text">User Manual</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="whatisnew.html">What is New?</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview of Supported EM Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="guides.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="datastructures.html">Data Structures</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="steps_supp_em_workflows.html">Steps of Supported EM Workflows</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="read_csv_files.html">Reading the CSV Files from Disk</a></li>
<li class="toctree-l2"><a class="reference internal" href="down_sampling.html">Down Sampling</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Specifying Blockers and Performing Blocking</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#types-of-blockers-and-blocker-hierarchy">Types of Blockers and Blocker Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#built-in-blockers">Built-In Blockers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blackbox-blockers">Blackbox Blockers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rule-based-blockers">Rule-Based Blockers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#combining-multiple-blockers">Combining Multiple Blockers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="create_feats_for_blocking.html">Creating Features for Blocking</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging_blocking.html">Debugging Blocking</a></li>
<li class="toctree-l2"><a class="reference internal" href="sampling.html">Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="labeling.html">Labeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="split_train_test.html">Splitting Labeled Data into Training and Testing Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="create_feats_for_matching.html">Creating Features for Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="extract_feat_vecs.html">Extracting Feature Vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="imputing_missing_values.html">Imputing Missing Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="matching.html">Specifying ML-Matchers and Performing Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="select_best_matcher.html">Selecting a ML-Matcher</a></li>
<li class="toctree-l2"><a class="reference internal" href="debugging_matcher.html">Debugging ML-Matchers</a></li>
<li class="toctree-l2"><a class="reference internal" href="evaluate_matching.html">Evaluating the Matching Output</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">Miscellaneous</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api/overview.html">Overview of Command Organization</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/actual_commands.html">Commands in py_entitymatching</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">py_entitymatching</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="steps_supp_em_workflows.html">Steps of Supported EM Workflows</a> &raquo;</li>
        
      <li>Specifying Blockers and Performing Blocking</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user_manual/blocking.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="specifying-blockers-and-performing-blocking">
<h1>Specifying Blockers and Performing Blocking<a class="headerlink" href="#specifying-blockers-and-performing-blocking" title="Permalink to this headline">¶</a></h1>
<p>In this section, we discuss how you can specify blockers and perform blocking.</p>
<div class="section" id="types-of-blockers-and-blocker-hierarchy">
<h2>Types of Blockers and Blocker Hierarchy<a class="headerlink" href="#types-of-blockers-and-blocker-hierarchy" title="Permalink to this headline">¶</a></h2>
<p>Once the tables are loaded and downsampled, most often you have to do blocking.
Note that by <em>blocking</em> we mean to block a <em>tuple pair</em> from going through to the
matching step. When applied to a tuple pair, a blocker returns <em>True</em> if the pair
should be blocked. You must know conceptually the types of blockers and
the blocker hierarchy in py_entitymatching to extend or modify them based on your need.</p>
<p>There are two types of blockers: (1) tuple-level, and (2) global. A tuple-level blocker
can examine a tuple pair in isolation and decide if it should be admitted to the next
stage. For example, an attribute equivalence blocker is a tuple-level blocker. A global
blocker cannot make this decision in isolation. It would need to examine a set of other
pairs as well. For example, a sorted neighborhood blocker applied over an union of the
input tables is a global blocker. Currently, py_entitymatching supports only
tuple-level blockers.</p>
<p>The blockers can be combined in complex ways, such as</p>
<ul class="simple">
<li>apply blocker <em>b1</em> to the two tables</li>
<li>apply blocker <em>b2</em> to the two tables</li>
<li>apply blocker <em>b3</em> to the output of <em>b1</em></li>
</ul>
<p>Further, you may just want to apply a blocker to just a pair of tuples, to see how
the blocker works.</p>
<p>In py_entitymatching, there is a Blocker class from which a set of concrete blockers
are inherited. These concrete blockers implement the following methods:</p>
<ul class="simple">
<li>block_tables (apply to input tables A and B)</li>
<li>block_candset (apply to an output from another blocker (e.g. table C))</li>
<li>block_tuples (apply to a tuple pair to check if it will survive blocking)</li>
</ul>
<p>In py_entitymatching, there are four concrete blockers implemented: (1) attribute
equivalence blocker, (2) overlap blocker, (3) rule-based blocker, and (4) black box
blocker. All the functions implemented in the concrete blockers are metadata aware.</p>
<p>The class diagram of Blocker and the concrete blockers inherited from it is shown below:</p>
<a class="reference internal image-reference" href="../_images/blocker_hierarchy.png"><img alt="'Blocker Hierarchy'" src="../_images/blocker_hierarchy.png" style="width: 1162.0px; height: 259.0px;" /></a>
</div>
<div class="section" id="built-in-blockers">
<h2>Built-In Blockers<a class="headerlink" href="#built-in-blockers" title="Permalink to this headline">¶</a></h2>
<p>Built-in blockers are those that have been built into py_entitymatching and you can just
simply call them. py_entitymatching currently offers two built-in blockers.</p>
<p><strong>Attribute Equivalence Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in attribute equivalence blocker
takes an attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that
is, drop the tuple pair) if <cite>x</cite> and <cite>y</cite> are not of the same value.</p>
<p>An example of using the above function is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.AttrEquivalenceBlocker.block_tables" title="py_entitymatching.AttrEquivalenceBlocker.block_tables"><code class="xref py py-meth docutils literal"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>. An example of using
<cite>block_candset</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.AttrEquivalenceBlocker.block_candset" title="py_entitymatching.AttrEquivalenceBlocker.block_candset"><code class="xref py py-meth docutils literal"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.AttrEquivalenceBlocker.block_tuples" title="py_entitymatching.AttrEquivalenceBlocker.block_tuples"><code class="xref py py-meth docutils literal"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
<p><strong>Overlap Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in overlap blocker takes an
attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that is, drop
the tuple pair) if <cite>x</cite> and <cite>y</cite> do not share any token (where the token is a word or
a q-gram).</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.OverlapBlocker.block_tables" title="py_entitymatching.OverlapBlocker.block_tables"><code class="xref py py-meth docutils literal"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.OverlapBlocker.block_candset" title="py_entitymatching.OverlapBlocker.block_candset"><code class="xref py py-meth docutils literal"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.OverlapBlocker.block_tuples" title="py_entitymatching.OverlapBlocker.block_tuples"><code class="xref py py-meth docutils literal"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
</div>
<div class="section" id="blackbox-blockers">
<h2>Blackbox Blockers<a class="headerlink" href="#blackbox-blockers" title="Permalink to this headline">¶</a></h2>
<p>By <cite>blackbox blockers</cite> we mean that the user supplies a Python function which
encodes blocking for a tuple pair. Specifically, the Python function will take
in two tuples and returns True if the tuple pair needs to be blocked, else
returns False. To use a blackbox blocker, first you must write a
blackbox blocker function.</p>
<p>An example of blackbox blocker function is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that there is a &#39;name&#39; attribute in the input tables</span>
    <span class="c1"># and each value in it has two words</span>
    <span class="n">l_last_name</span> <span class="o">=</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r_last_name</span> <span class="o">=</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">l_last_name</span> <span class="o">!=</span> <span class="n">r_last_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>Then instantiate a <cite>blackbox blocker</cite> and set the blocking function function as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, you can call <cite>block_tables</cite> on the input tables. Conceptually, <cite>block_tables</cite> would
apply the blackbox blocker function on the Cartesian product of the input tables A and B, and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.BlackBoxBlocker.block_tables" title="py_entitymatching.BlackBoxBlocker.block_tables"><code class="xref py py-meth docutils literal"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.BlackBoxBlocker.block_candset" title="py_entitymatching.BlackBoxBlocker.block_candset"><code class="xref py py-meth docutils literal"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>Further, <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.BlackBoxBlocker.block_tuples" title="py_entitymatching.BlackBoxBlocker.block_tuples"><code class="xref py py-meth docutils literal"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
</div>
<div class="section" id="rule-based-blockers">
<h2>Rule-Based Blockers<a class="headerlink" href="#rule-based-blockers" title="Permalink to this headline">¶</a></h2>
<p>You can write a few domain specific rules (for blocking purposes) using rule-based blocker.
If you want to write rules, then you must start by defining a set of features.
Each <cite>feature</cite> is a function that when applied to a tuple pair will return a
numeric value. We will discuss how to create a set of features in the section
<a class="reference internal" href="create_feats_for_blocking.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>block_f</cite>. Then you will be able
to instantiate a rule-based blocker and add rules like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>block_f</cite> is a set of features stored as a Dataframe (see section
<a class="reference internal" href="create_feats_for_blocking.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The blocker is then a disjunction of rules.
That is, even if one of the rules return True, then the tuple pair will be blocked.</p>
<p>Once the rules are specified, you can call <cite>block_tables</cite> on the input tables.
Conceptually, <cite>block_tables</cite> would
apply the rule-based blocker function on the Cartesian product of the input tables A and B and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.RuleBasedBlocker.block_tables" title="py_entitymatching.RuleBasedBlocker.block_tables"><code class="xref py py-meth docutils literal"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.RuleBasedBlocker.block_candset" title="py_entitymatching.RuleBasedBlocker.block_candset"><code class="xref py py-meth docutils literal"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="api/blocking.html#py_entitymatching.RuleBasedBlocker.block_tuples" title="py_entitymatching.RuleBasedBlocker.block_tuples"><code class="xref py py-meth docutils literal"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
</div>
<div class="section" id="combining-multiple-blockers">
<h2>Combining Multiple Blockers<a class="headerlink" href="#combining-multiple-blockers" title="Permalink to this headline">¶</a></h2>
<p>If you use multiple blockers, then you have to combine them to get a
consolidated candidate set. There are many different ways to combine the candidate sets
such as doing union, majority vote, weighted vote, etc. Currently, py_entitymatching
only supports union-based combining.</p>
<p>In py_entitymatching, <cite>combine_blocker_outputs_via_union</cite> is used to do union-based
combining.</p>
<p>An example of using <cite>combine_blocker_outputs_via_union</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">combine_blocker_outputs_via_union</span><span class="p">([</span><span class="n">C</span><span class="p">,</span> <span class="n">E</span><span class="p">])</span>
</pre></div>
</div>
<p>Conceptually, the command takes in a list of blocker outputs (i.e. pandas Dataframes) and
produces a consolidated table. The output table contains the union of tuple pair ids and
other attributes from the input list.</p>
<p>Please look at the API reference of <a class="reference internal" href="api/combining_blocker_outputs.html#py_entitymatching.combine_blocker_outputs_via_union" title="py_entitymatching.combine_blocker_outputs_via_union"><code class="xref py py-meth docutils literal"><span class="pre">combine_blocker_outputs_via_union()</span></code></a>
for more details.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="create_feats_for_blocking.html" class="btn btn-neutral float-right" title="Creating Features for Blocking" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="down_sampling.html" class="btn btn-neutral" title="Down Sampling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, anhaidgroup.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>