

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>py_entitymatching 0.3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">py_entitymatching 0.3.0 documentation</a> &#187;</li> 
      </ul>
    </div>
<div class="content-wrapper">
    <div class="content">
        <div class="document">
            <div class="sphinxsidebar">
                <h3>Table Of Contents</h3>
                <p class="caption"><span class="caption-text">How To Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-how_to_guide">How to Guide To Do Entity Matching</a></li>
</ul>
<p class="caption"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/whatisnew">What is New?</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/overview">Overview of Supported EM Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/guides">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/datastructures">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/steps_supp_em_workflows">Steps of Supported EM Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/misc">Miscellaneous</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/api/overview">Overview of Command Organization</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/api/actual_commands">Commands in py_entitymatching</a></li>
</ul>

                <h3 style="margin-top: 1.5em;">Search</h3>

                <form class="search" action="search.html" method="get">
                    <input type="text" name="q" size="18"/>
                    <input type="submit" value="Go"/>
                    <input type="hidden" name="check_keywords" value="yes"/>
                    <input type="hidden" name="area" value="default"/>
                </form>
                <p class="searchtip" style="font-size: 90%">
                    Enter search terms or a module, class or function name.
                </p>

            </div>
             
            <div class="documentwrapper">
                <div class="bodywrapper">
                    <div class="body">
                        
  <div class="section" id="user-manual-for-py-entitymatching">
<h1>User Manual for py_entitymatching<a class="headerlink" href="#user-manual-for-py-entitymatching" title="Permalink to this headline">¶</a></h1>
<p>This document explains how to install and use the package.
To contribute to the package, see the
<a class="reference external" href="https://sites.google.com/site/anhaidgroup/projects/py_entitymatching">project website</a>,
section “For Contributors and Developers”.</p>
</div>
<div class="section" id="contents">
<h1>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-how_to_guide"></span><div class="section" id="how-to-guide-to-do-entity-matching">
<h2>How to Guide To Do Entity Matching<a class="headerlink" href="#how-to-guide-to-do-entity-matching" title="Permalink to this headline">¶</a></h2>
<p>The initial draft of the how to guide to do entity matching can be found <a class="reference external" href="http://pradap-www.cs.wisc.edu/magellan/how-to-guide/how_to_guide_magellan.pdf">here.</a></p>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-user_manual/whatisnew"></span><div class="section" id="what-is-new">
<h2>What is New?<a class="headerlink" href="#what-is-new" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Compared to version 0.2.0, the followings are new:</dt>
<dd><ul class="first last simple">
<li>Updated debug blocker code to use Cython</li>
<li>Added rule-based matcher and rule-based trigger</li>
<li>Updated new labeler with unit test cases</li>
</ul>
</dd>
<dt>Compared to version 0.1.0, the followings are new:</dt>
<dd><ul class="first last simple">
<li>Updated the down sampler command to let  the user to set the random seed.</li>
<li>Updated documentation to profile dataframe using pandas-profiling package.</li>
<li>Added support for exploring pandas dataframe using pandastable and openrefine wrappers.</li>
<li>Updated the GUI code to use PyQt5.</li>
<li>Added experimental labeler with better GUI.</li>
<li>Updated auto feature generation module to validate inferred attribute types with the user.</li>
<li>Updated the select_matcher to show results for multiple metrics.</li>
<li>Added support for XGBoost classifier.</li>
<li>Fixed bugs based on the feedback from CS838 students and RIT.</li>
<li>Fixed documentation errors report by CS838 students.</li>
</ul>
</dd>
</dl>
</div>
<span id="document-user_manual/installation"></span><div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Python 2.7 or Python 3.4+</li>
</ul>
</div>
<div class="section" id="platforms">
<h3>Platforms<a class="headerlink" href="#platforms" title="Permalink to this headline">¶</a></h3>
<p>py_entitymatching has been tested on Linux (Redhat enterprise Linux with 2.6
.32 kernel), OS X (Sierra), and Windows 10.</p>
</div>
<div class="section" id="dependencies">
<h3>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>pandas (provides data structures to store and manage tables)</li>
<li>scikit-learn (provides implementations for common machine learning algorithms)</li>
<li>joblib (provides multiprocessing capabilities)</li>
<li>pyqt5 (provides tools to build GUIs)</li>
<li>py_stringsimjoin (provides implementations for string similarity joins)</li>
<li>py_stringmatching (provides a set of string tokenizers and string similarity functions)</li>
<li>cloudpickle (provides functions to serialize Python constructs)</li>
<li>pyprind (library to display progress indicators)</li>
<li>pyparsing (library to parse strings)</li>
<li>six (provides functions to write compatible code across Python 2 and 3)</li>
<li>xgboost (provides an implementation for xgboost classifier)</li>
<li>pandas-profiling (provides implementation for profiling pandas dataframe)</li>
<li>pandas-table (provides data exploration tool for pandas dataframe)</li>
<li>openrefine (provides data exploration tool for tables)</li>
</ul>
</div>
<div class="section" id="installing-using-conda">
<h3>Installing Using conda<a class="headerlink" href="#installing-using-conda" title="Permalink to this headline">¶</a></h3>
<p>The easiest and recommended way to install the package is to use the command conda,
which will retrieve py_entitymatching from Anaconda repository then install it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">install</span> <span class="o">-</span><span class="n">c</span> <span class="n">uwmagellan</span> <span class="n">py_entitymatching</span>
</pre></div>
</div>
<p>The above command will install py_entitymatching and all of its dependencies except
XGBoost, pandastable, openrefine and PyQt5. As these packages are either not available from
anaconda cloud (for some Python versions or operating systems) or they are not Python
packages (openrefine).</p>
<ul class="simple">
<li>To install PyQt5, follow the instructions at <a class="reference external" href="http://pyqt.sourceforge.net/Docs/PyQt5/installation.html">this page</a>.</li>
<li>To install XGBoost manually from the source follow the instructions on <a class="reference external" href="https://XGBoost.readthedocs.io/en/latest/build.html">this page</a>.</li>
<li>To install pandastable follow the instructions at <a class="reference external" href="https://github.com/dmnfarrell/pandastable">this page</a>.</li>
<li>To install openrefine follow the instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">this page</a>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To use the command conda, first you must install Miniconda or Anaconda. For
more details refer to this <a class="reference external" href="http://conda.pydata.org/docs/using/index.html">conda page</a>.</p>
</div>
</div>
<div class="section" id="installing-using-pip">
<h3>Installing Using pip<a class="headerlink" href="#installing-using-pip" title="Permalink to this headline">¶</a></h3>
<p>To install the package using pip, execute the following
command:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">numpy</span> <span class="n">scipy</span> <span class="n">py_entitymatching</span>
</pre></div>
</div>
<p>The above command will install py_entitymatching and all of its dependencies except
XGBoost, pandastable, openrefine, and PyQt5. This is because pip can only install the
dependency packages that are available in PyPI and PyQt5, XGBoost, pandastable are not
in PyPI for Python 2.</p>
<ul class="simple">
<li>To install PyQt5, follow the instructions at <a class="reference external" href="http://pyqt.sourceforge.net/Docs/PyQt5/installation.html">this page</a>.</li>
<li>To install XGBoost, follow the instructions at <a class="reference external" href="https://XGBoost.readthedocs.io/en/latest/build.html">this page</a>.</li>
<li>To install pandastable follow the instructions at <a class="reference external" href="https://github.com/dmnfarrell/pandastable">this page</a>.</li>
<li>To install openrefine follow the instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">this page</a>.</li>
</ul>
</div>
<div class="section" id="installing-from-source-distribution">
<h3>Installing from Source Distribution<a class="headerlink" href="#installing-from-source-distribution" title="Permalink to this headline">¶</a></h3>
<p>Clone the py_entitymatching package from GitHub</p>
<blockquote>
<div>git clone  <a class="reference external" href="https://github.com/anhaidgroup/py_entitymatching.git">https://github.com/anhaidgroup/py_entitymatching.git</a></div></blockquote>
<p>Then,  execute the following commands from the package root:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">numpy</span> <span class="n">scipy</span>
<span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span>
</pre></div>
</div>
<p>which installs py_stringmatching into the default Python directory on your machine. If you do not have installation permission for that directory then you can install the package in your
home directory as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span>
</pre></div>
</div>
<p>For more information see this StackOverflow <a class="reference external" href="http://stackoverflow.com/questions/14179941/how-to-install-python-packages-without-root-privileges">link</a>.</p>
<p>The above commands will install py_entitymatching and all of its
dependencies, except PyQt5 and XGBoost.</p>
<p>This is  because, similar to pip, setup.py can only install the dependency packages
that are available in PyPI and PyQt5, pandastable, XGBoost are not in PyPI for Python 2.</p>
<ul class="simple">
<li>To install PyQt5, follow the instructions at <a class="reference external" href="http://pyqt.sourceforge.net/Docs/PyQt5/installation.html">this page</a>.</li>
<li>To install XGBoost, follow the instructions at <a class="reference external" href="https://XGBoost.readthedocs.io/en/latest/build.html">this page</a>.</li>
<li>To install pandastable follow the instructions at <a class="reference external" href="https://github.com/dmnfarrell/pandastable">this page</a>.</li>
<li>To install openrefine follow the instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">this page</a>.</li>
</ul>
</div>
</div>
<span id="document-user_manual/overview"></span><div class="section" id="overview-of-supported-em-processes">
<h2>Overview of Supported EM Processes<a class="headerlink" href="#overview-of-supported-em-processes" title="Permalink to this headline">¶</a></h2>
<p>In this section we provide a high-level overview of the EM processes supported by
py_entitymatching. For more details, please read the document “How-To Guide to Entity Matching”
(will soon be available from the package website).</p>
<div class="section" id="supported-em-problem-scenarios">
<h3>Supported EM Problem Scenarios<a class="headerlink" href="#supported-em-problem-scenarios" title="Permalink to this headline">¶</a></h3>
<p>Entity matching (EM) has many problem variations: matching two tables, matching within a
single table, matching from a table into a knowledge base, etc. The package currently only
support matching two tables. Specifically, given two tables A and B of relational tuples,
find all tuple pairs (a in A, b in B) such that a and b refer to the same real-world
entity. The following figure shows an example of matching persons between two given tables.</p>
<a class="reference internal image-reference" href="_images/example-match-two-tables.png"><img alt="'An example of matching two tables'" class="align-center" src="_images/example-match-two-tables.png" style="width: 300.0px; height: 120.0px;" /></a>
<p>Of course, if you want to match tuples within a single table X, you can also use
the package, by matching X with X (you do not have to create another copy of X,
just provide X twice as the input if a command in the package requires two tables A
and B as the input).</p>
</div>
<div class="section" id="two-fundamental-steps-in-the-em-process-blocking-and-matching">
<h3>Two Fundamental Steps in the EM Process: Blocking and Matching<a class="headerlink" href="#two-fundamental-steps-in-the-em-process-blocking-and-matching" title="Permalink to this headline">¶</a></h3>
<p>In practice, tables A and B can be quite large, such as having 100K tuples each, resulting
in 10 billions tuple pairs across A and B. Trying to match all of these pairs is clearly
very expensive. Thus, in such cases the user often employs domain heuristics to quickly
remove obviously non-matched pairs, in a step called <em>blocking</em>, before matching the
remaining pairs, in a step called <em>matching</em>.</p>
<p>The following figure illustrates the above two fundamental steps. Suppose that we are
matching the two tables A and B in (a), where each tuple describes a person. The blocking
step can use a heuristic such as “if two tuples do not agree on state, then they cannot
refer to the same person” to quickly remove all such tuple pairs (this is typically
done using indexes, so the blocking step does not have to enumerate all tuple pairs
between A and B). In other words, the blocking step retains only the four tuple pairs
that agree on state, as shown in (b). The matching step in (c) then considers only these
tuple pairs and predicts for each of them a label “match” or “not-match”
(shown as “+” and “-” in the figure).</p>
<a class="reference internal image-reference" href="_images/example-blocking-matching.png"><img alt="'An example of blocking and matching'" class="align-center" src="_images/example-blocking-matching.png" style="width: 500.0px; height: 220.0px;" /></a>
</div>
<div class="section" id="supported-em-workflows">
<h3>Supported EM Workflows<a class="headerlink" href="#supported-em-workflows" title="Permalink to this headline">¶</a></h3>
<p>The current package supports EM workflows that consist of a blocking step followed by a matching step. Specifically, the package provides a set of blockers and a set of matchers (and the user can easily write his or her own blocker/matcher). Given two tables A and B to be matched, the user applies a blocker to the two tables to obtain a set of tuple pairs, then applies a matcher to these pairs to predict “match” or “no-match”. The user can use multiple blockers in the blocking step, and can combine them in flexible ways. The figure below illustrates both cases.</p>
<a class="reference internal image-reference" href="_images/example-workflow.png"><img alt="'An example of EM workflow'" class="align-center" src="_images/example-workflow.png" style="width: 617.5px; height: 90.25px;" /></a>
<p>Further, the current package supports both rule-based and learning-based matchers. Specifically, rule-based matchers will require the user to write domain specific match rules and learning-based matchers  will require the user to label a set of tuple pairs (as “match” or “no-match”), then use the labeled data to train matchers. In the future, we will consider extending the package to support more powerful EM workflows, such as using multiple matchers, or being able to add rules to process the output of the matchers.</p>
</div>
<div class="section" id="the-development-and-production-stages">
<h3>The Development and Production Stages<a class="headerlink" href="#the-development-and-production-stages" title="Permalink to this headline">¶</a></h3>
<p>In practice EM is typically carried out in two stages. In the development stage, the user tries to find an accurate EM workflow, often using data samples. In the production stage, the user then executes the discovered workflow on the entirety of data. The following figure illustrates the development stage, which is the focus of the current package. The figure also highlights the steps of the development stage that the current package supports.</p>
<p>In the figure, suppose we want to match two tables A and B, each having 1 million tuples. Trying to explore and discover an accurate workflow using these two tables would be too time consuming, because they are too big. Hence, the user will first “down sample” the two tables to obtain two smaller versions, shown as Tables A’ and B’ in the figure, each having 100K tuples, say (see the figure).</p>
<a class="reference internal image-reference" href="_images/example-dev-stage.png"><img alt="'An example of the development stage'" class="align-center" src="_images/example-dev-stage.png" style="width: 500.0px; height: 300.0px;" /></a>
<p>Next, suppose the package provides two blockers X and Y. Then the user will experiment with these blockers (for example, executing both on Tables A’ and B’ and examining their output) to select the blocker judged the best (according to some criterion). Suppose the user selects blocker X. Then next, he or she executes X on Tables A’ and B’ to obtain a set of candidate tuple pairs C.</p>
<p>Next, the user takes a sample S from C, and labels the pairs in S as “match” or “no-match” (see the figure). Let the labeled set be G, and suppose the package provides two matchers U and V. Suppose further that U and V are learning-based matchers (for example, one uses decision trees and the other uses logistic regression). Then in the next step, the user will use the labeled set G to perform cross validation for U and V. Suppose V produces higher matching accuracy (such as F1 score of 0.93, see the figure). Then the user will select V as the matcher, then apply V to the set C to predict “match” or “no-match”, shown as “+” or “-” in the figure. Finally, the user may perform quality check (by examining a sample of the predictions), then go back and debug and modify the previous steps as appropriate. This continues until the user is satisfied with the accuracy of the EM workflow.</p>
<p>Once the user has been satisfied with the EM workflow, the production stage begins. In this stage the user will execute the discovered workflow on the original tables A and B. Since these tables are very large, scaling is a major concern (and is typically solved using Hadoop or Spark). Other concerns include quality monitoring, exception handling, crash recovery, etc.</p>
</div>
<div class="section" id="the-focus-of-the-current-package">
<h3>The Focus of the Current Package<a class="headerlink" href="#the-focus-of-the-current-package" title="Permalink to this headline">¶</a></h3>
<p>The current py_entitymatching package focuses on helping the user with the development stage, that is, help him or her discover an accurate EM workflow. In the future, we will extend the package to also help the user with the production stage.</p>
</div>
</div>
<span id="document-user_manual/guides"></span><div class="section" id="guides">
<h2>Guides<a class="headerlink" href="#guides" title="Permalink to this headline">¶</a></h2>
<p>The goal of this page  is to give you some concrete examples for using py_entitymatching.
These are examples with sample data that is already bundled along with the package. The
examples are in the form of Jupyter notebooks.</p>
<div class="section" id="a-quick-tour-of-jupyter-notebook">
<h3>A Quick Tour of Jupyter Notebook<a class="headerlink" href="#a-quick-tour-of-jupyter-notebook" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/index.html">This tutorial</a>
gives a quick tour on installing and using Jupyter notebook.</p>
</div>
<div class="section" id="end-to-end-em-workflows">
<h3>End-to-End EM Workflows<a class="headerlink" href="#end-to-end-em-workflows" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>EM workflow with blocking using a overlap blocker and matching using Random Forest
matcher: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%201.ipynb">Jupyter notebook</a></li>
<li>EM workflow with blocking using a overlap blocker, selecting among multiple matchers,
using the selected matcher to predict matches, and evaluating the predicted matches: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%202.ipynb">Jupyter notebook</a></li>
<li>EM workflow with blocking using multiple blockers (overlap and attribute equivalence
blocker), debugging the blocker output, selecting among multiple matchers, debugging the
matcher output, using the selected matcher to predict matches, and evaluating the
predicted matches: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%203.ipynb">Jupyter notebook</a></li>
</ul>
</div>
<div class="section" id="stepwise-guides">
<h3>Stepwise Guides<a class="headerlink" href="#stepwise-guides" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Reading CSV files from disk: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Reading%20CSV%20Files%20from%20Disk.ipynb">Jupyter notebook</a></p>
</li>
<li><p class="first">Down sampling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Down%20Sampling.ipynb">Jupyter notebook</a></p>
</li>
<li><p class="first">Data profiling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Data%20Profiling.ipynb">Jupyter notebook</a></p>
</li>
<li><p class="first">Data exploration: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Data%20Exploration.ipynb">Jupyter notebook</a></p>
</li>
<li><p class="first">Blocking:</p>
<blockquote>
<div><ul class="simple">
<li>Using overlap blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Built-In%20Blockers%20%28Overlap%20Blocker%29.ipynb">Jupyter notebook</a></li>
<li>Using attribute equivalence blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Built-In%20Blockers%20%28Attr.%20Equivalence%20Blocker%29.ipynb">Jupyter notebook</a></li>
<li>Using rule-based blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Rule-Based%20Blocking.ipynb">Jupyter notebook</a></li>
<li>Using blackbox blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Blackbox%20Blocker.ipynb">Jupyter notebook</a></li>
<li>Combining multiple blockers: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Combining%20Multiple%20Blockers.ipynb">Jupyter notebook</a></li>
<li>Debugging blocker output: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Debugging%20Blocker%20Output.ipynb">Jupyter notebook</a></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Handling features:</p>
<blockquote>
<div><ul class="simple">
<li>Generating features manually: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Generating%20Features%20Manually.ipynb">Jupyter notebook</a></li>
<li>Editing attribute types and generating features manually: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Editing%20and%20Generating%20Features%20Manually.ipynb">Jupyter notebook</a></li>
<li>Adding features to feature table: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Adding%20Features%20to%20Feature%20Table.ipynb">Jupyter notebook</a></li>
<li>Removing features from feature table: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Removing%20Features%20From%20Feature%20Table.ipynb">Jupyter notebook</a></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Sampling and labeling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Sampling%20and%20Labeling.ipynb">Jupyter notebook</a></p>
</li>
<li><p class="first">Matching:</p>
<blockquote>
<div><ul class="simple">
<li>Selecting the best learning-based matcher (involves splitting the labeled data, generating features,
instantiating multiple matchers, debugging the matcher output): <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Selecting%20the%20Best%20Learning%20Matcher.ipynb">Jupyter notebook</a></li>
<li>Performing matching using rule-based matcher: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Matching%20with%20a%20Rule-Based%20Matcher.ipynb">Jupyter notebook</a></li>
<li>Improving matching results using triggers: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Using%20Match%20Triggers%20to%20Improve%20Results.ipynb">Jupyter notebook</a></li>
<li>Evaluating the predictions from a matcher:  <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Evaluating%20the%20Selected%20Matcher.ipynb">Jupyter notebook</a></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<span id="document-user_manual/datastructures"></span><div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p>In py_entitymatching, we will need to store many tables and metadata associated
with it. It is important for you to know the data structures that are used to store
the tables and the metadata, so that you can manipulate them based on your need.</p>
<p>As a convention, we will use:</p>
<ul class="simple">
<li>A and B to refer to the original two tables to be matched,</li>
<li>C to refer to the candidate set table obtained from A and B after the blocking step,</li>
<li>S to refer to a sample taken from C, and</li>
<li>G to refer to a table that contains the tuple pairs in S and a golden label for each
pair (indicating the pair as matches or non-matches).</li>
</ul>
<div class="section" id="storing-tables-using-pandas-dataframes">
<h3>Storing Tables Using Pandas Dataframes<a class="headerlink" href="#storing-tables-using-pandas-dataframes" title="Permalink to this headline">¶</a></h3>
<p>We will need to store a lot of data as tables in py_entitymatching. We use pandas Dataframes to
represent tables (you can read more about pandas and pandas Dataframes <a class="reference external" href="http://pandas.pydata.org/">here</a>).</p>
<p><strong>Tuple:</strong> We often refer to a row of a table as tuple. Each tuple is just a row
in a Dataframe and this is of type pandas Series (you can read more about pandas Series
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html">here</a>).</p>
</div>
<div class="section" id="storing-metadata-using-a-catalog">
<h3>Storing Metadata Using a Catalog<a class="headerlink" href="#storing-metadata-using-a-catalog" title="Permalink to this headline">¶</a></h3>
<p><strong>Bare Minimum that You Should Know:</strong>
In py_entitymatching, we need to store a lot of metadata with a table such as
key and foreign key. We use a
new data structure, Catalog, to store metadata. You need not worry
about instantiating this object (it gets automatically instantiated when py_entitymatching
gets loaded in Python memory) or manipulating this object directly.</p>
<p>All the py_entitymatching commands correctly handle the metadata in the Catalog,
and for you, there are commands to manipulate the Catalog (please see
<a class="reference internal" href="index.html#label-handling-metadata"><span class="std std-ref">Handling Metadata</span></a> section for the supported commands).</p>
<p><strong>If You Want to Read More:</strong>
As we mentioned earlier,  we need to store a lot of metadata with a table. Here are a few examples:</p>
<ul class="simple">
<li>Each table in py_entitymatching should have a key, so that we can easily identify the tuples.
Keys are also critical later for debugging, provenance, etc. Key is a metadata that we
want to store for a table.</li>
<li>The blocking step will create tuple pairs from two tables A and B. For example,
suppose we have table A(aid, a, b) and table B(bid, x, y), then the tuple pairs can be
stored in a candidate set table C(cid, aid, bid, a, b, x, y). This table could be very
big, taking up a lot of space in memory. To save space, we may want to just store C as
C(cid, aid, bid) and then have pointers back to tables A and B. The two pointers back
to A and B are metadata that we may want to store for table C. Specifically, the
metadata for C include key (<cite>cid</cite>) and foreign keys (<cite>aid</cite>, <cite>bid</cite>) to the base tables
(<cite>A</cite>, <cite>B</cite>).</li>
</ul>
<p>There are many other examples of metadata that we may want to store for a table. Though
pandas Dataframes is a good choice for storing data as tables, it does not provide a
robust way to store metadata (for more discussion on this topic, please look at <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2485">this thread</a>).
To tackle this, we have a new data structure, <cite>Catalog</cite> to store the metadata for tables.</p>
<p>Conceptually, Catalog is a dictionary, where the keys are unique identifiers for
each Dataframe and the values are dictionaries containing metadata.
This dictionary can have different kinds of keys that point to metadata.
Examples of such keys are:</p>
<ul class="simple">
<li>key: the name of the key attribute of the table.</li>
<li>ltable: pointer to the left table (see below).</li>
<li>rtable: pointer to the right table (see below).</li>
</ul>
<p>The kind of metadata stored for a table would depend on the table itself. For example,
the input tables must have a key and this can be the only metadata.</p>
<p>But, if we consider table C (which is obtained by performing blocking on input tables A
and B), this table can be very large, so we typically represent it using a view over
two tables A and B. Such a table C will have the following attributes:</p>
<ul class="simple">
<li>_id (key attribute of table C).</li>
<li>ltable_aid (aid is the key attribute in table A).</li>
<li>rtable_bid (bid is the key attribute in table B).</li>
<li>some attributes from A and B.</li>
</ul>
<p>The metadata dictionary for table C will have at least these fields:</p>
<ul class="simple">
<li>key: _id.</li>
<li>ltable: points to table A.</li>
<li>rtable: points to table B.</li>
<li>fk_ltable: ltable_aid (that is, ltable.aid is a foreign key of table A).</li>
<li>fk_rtable: rtable_bid.</li>
</ul>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Tables in py_entitymatching are represented as pandas Dataframes.</li>
<li>The metadata for tables are stored in a separate data structure called Catalog.</li>
<li>The kind of metadata stored will depend on the table (for example input table will have key,
and the table from blocking will have key, ltable, rtable, fk_table, fk_rtable).</li>
<li>So there are five reserved keywords for metadata: key, ltable, rtable, fk_ltable,
fk_rtable. You should not use these names to store metadata for other application
specific purposes.</li>
</ul>
</div>
</div>
<span id="document-user_manual/steps_supp_em_workflows"></span><div class="section" id="steps-of-supported-em-workflows">
<h2>Steps of Supported EM Workflows<a class="headerlink" href="#steps-of-supported-em-workflows" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/read_csv_files"></span><div class="section" id="reading-the-csv-files-from-disk">
<h3>Reading the CSV Files from Disk<a class="headerlink" href="#reading-the-csv-files-from-disk" title="Permalink to this headline">¶</a></h3>
<p>Currently, py_entitymatching only asupports reading CSV files from disk.</p>
<p><strong>The Minimal That You Should Do:</strong> First, you must store the input tables as CSV files
in disk. Please look at section <a class="reference internal" href="index.html#label-csv-format"><span class="std std-ref">CSV Format</span></a> to learn more
about CSV format. An example of a CSV file will look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">birth_year</span><span class="p">,</span> <span class="n">hourly_wage</span><span class="p">,</span> <span class="n">zipcode</span>
<span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94121</span>
</pre></div>
</div>
<p>Next, each table in py_entitymatching must have a key column. If the table already
has a key column, then you can read the CSV file and set the key column as like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># ID is the key column in table.csv</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the table does not have a key column, then you can read the CSV file, add a
key column and set the added key column like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Read the CSV file</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">)</span>
<span class="c1"># Add a key column with name &#39;ID&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="c1"># Set &#39;ID&#39; as the key column</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>If You Want to Read and Play Around More:</strong> In general, the command
<a class="reference internal" href="index.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal"><span class="pre">read_csv_metadata()</span></code></a> looks for a file (with the same file name
as the <cite>CSV</cite> file) with <cite>.metadata</cite> extension in the same directory containing the
metadata. If the file containing metadata information is not present, then
<a class="reference internal" href="index.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal"><span class="pre">read_csv_metadata()</span></code></a> will proceed just reading the CSV file
as mentioned in the command.</p>
<p>To update the metadata for a table, using a metadata file, first, you must manually create
this file and specify the metadata for a table and then call
<a class="reference internal" href="index.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal"><span class="pre">read_csv_metadata()</span></code></a>. The command will automatically read the metadata from the
file and update the Catalog.</p>
<p>For example, if you read <cite>table.csv</cite> then <a class="reference internal" href="index.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal"><span class="pre">read_csv_metadata()</span></code></a>
looks for <cite>table.metadata</cite> file. The contents of <cite>table.metadata</cite> may look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#key=ID</span>
</pre></div>
</div>
<p>Each line in the file starts with <cite>#</cite>. The metadata is written as <cite>key=value</cite> pairs,
one in each line. The contents of the above file says that <cite>ID</cite> is the key attribute
(for the table in the file <cite>table.csv</cite>).</p>
<p>The table mentioned in the above example along with the metadata file
stored in the same directory can be read as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once, the table is read, you can check to see which
attribute of the table is a key using <a class="reference internal" href="index.html#py_entitymatching.get_key" title="py_entitymatching.get_key"><code class="xref py py-meth docutils literal"><span class="pre">get_key()</span></code></a> command as
shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">   &#39;ID&#39;</span>
</pre></div>
</div>
<p>As you see, the key for the table is updated correctly as ‘ID’.</p>
<p>See <a class="reference internal" href="index.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal"><span class="pre">read_csv_metadata()</span></code></a> for more details.</p>
</div>
<span id="document-user_manual/down_sampling"></span><div class="section" id="down-sampling">
<h3>Down Sampling<a class="headerlink" href="#down-sampling" title="Permalink to this headline">¶</a></h3>
<p>Once the tables to be matched are read, they must be down sampled if the number of
tuples in them are large (for example, 100K+ tuples). This is because working with
large tables can be very time consuming (as any operation performed would have
to process these large tables).</p>
<p>Random sampling however does not work, because the sampled may end up sharing very
few matches, especially if the number of matches between the
input tables are small to begin with.</p>
<p>In py_entitymatching, you can use sample the input tables using <cite>down_sample</cite> command.
This command samples the input tables intelligently that ensures a reasonable number of
matches between them.</p>
<p>If <cite>A</cite> and <cite>B</cite> are the input tables, then you can use <cite>down_sample</cite> command as shown
below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_A</span><span class="p">,</span> <span class="n">sample_B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">down_sample</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y_param</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Conceptually, the command takes in two original input tables, <cite>A</cite>, <cite>B</cite> (and some parameters),
and produces two sampled tables, <cite>sample_A</cite> and <cite>sample_B</cite>.
Specifically, you must set the <cite>size</cite> to be the number of tuples that
should be sampled from <cite>B</cite> (this will be the size of <cite>sample_B</cite> table) and set the
<cite>y_param</cite> to be the number of tuples to be selected from <cite>A</cite> (for each tuple in
<cite>sample_B</cite> table). The command internally uses a
heuristic to ensure a reasonable number of matches between <cite>sample_A</cite> and <cite>sample_B</cite>.</p>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.down_sample" title="py_entitymatching.down_sample"><code class="xref py py-meth docutils literal"><span class="pre">down_sample()</span></code></a> for more
details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, the input tables must be loaded in memory before the user can down
sample.</p>
</div>
</div>
<span id="document-user_manual/profiling"></span><div class="section" id="profiling-data">
<h3>Profiling Data<a class="headerlink" href="#profiling-data" title="Permalink to this headline">¶</a></h3>
<p>Profiling data is used to help users get general information about their data.
Before working with the data, it is useful for a user to have a high level
understanding of the data because he or she will be able to take advantage of
the the general trends to successfully and efficiently complete the rest of
the workflow.</p>
<p>Data profiling specifically can show users important statistics such as type,
uniqueness, missing values, quartile statistics, mean, mode, standard deviation,
sum, median absolute deviation, coefficient of variation, kurtosis, skewness.
It can also display information to the user visually such as in a histogram.</p>
<p>We recommend using the python package pandas-profiling because it is simple
and easy to use. More information about the package can be found on the github
page at <a class="reference external" href="https://github.com/JosPolfliet/pandas-profiling">https://github.com/JosPolfliet/pandas-profiling</a></p>
<div class="section" id="example-usage">
<h4>Example Usage<a class="headerlink" href="#example-usage" title="Permalink to this headline">¶</a></h4>
<p>After reading in a CSV file into a Dataframe, pandas-profiling shows the user a
report containing useful profiling information. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read in csv file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use the profiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The user can also check to see if any variables are highly correlated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read in csv file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#Use the profiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check for rejected variables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rejected_variables</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">get_rejected_variables</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
<p>The report generated can also be saved into an html file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save report to a variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save report to an html file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">outputfile</span><span class="o">=</span><span class="s2">&quot;/tmp/myoutputfile.html&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information about pandas-profiling please go to the github page
at <a class="reference external" href="https://github.com/JosPolfliet/pandas-profiling">https://github.com/JosPolfliet/pandas-profiling</a></p>
</div>
</div>
<span id="document-user_manual/data_exploration"></span><div class="section" id="data-exploration">
<h3>Data Exploration<a class="headerlink" href="#data-exploration" title="Permalink to this headline">¶</a></h3>
<p>Data exploration is an important part of the entity matching workflow because it
gives the user a chance to look at the actual data closely. Data exploration
allows the user to inspect the individual records and features present in the
table so that he or she can understand the important trends and relationships
present in the data. A complete understanding of the data gives the user an
advantage later on in the entity matching workflow.</p>
<div class="section" id="openrefine">
<h4>OpenRefine<a class="headerlink" href="#openrefine" title="Permalink to this headline">¶</a></h4>
<p>OpenRefine is a data exploration tool that is compatible with Python &gt;= 2.7 or
Python &gt;= 3.4. More information about OpenRefine can be found at its github page
at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine">https://github.com/OpenRefine/OpenRefine</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">OpenRefine is not included with py_entitymatching and must be downloaded and
installed separately. The installation instructions can be found at
<a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions</a></p>
</div>
<div class="section" id="using-openrefine">
<h5>Using OpenRefine<a class="headerlink" href="#using-openrefine" title="Permalink to this headline">¶</a></h5>
<p>Before using OpenRefine, you must start the application to start an OpenRefine
server. The explanations for doing so are explained after the installation
instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions</a></p>
<p>Once the application has created a server, copy the URL from the address bar of
the OpenRefine browser (default is <a class="reference external" href="http://127.0.0.1:3333">http://127.0.0.1:3333</a> ). Then the data can
be explored as in the example below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">data_explore_openrefine</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Table&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save the project back to our dataframe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calling export_pandas_frame will automatically delete the OpenRefine project</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">export_pandas_frame</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pandastable">
<h4>Pandastable<a class="headerlink" href="#pandastable" title="Permalink to this headline">¶</a></h4>
<p>Pandastable is a data exploration tool available for python &gt;=3.4 that allows users
to view and manipulate data. More information about pandastable can be found at
<a class="reference external" href="https://github.com/dmnfarrell/pandastable">https://github.com/dmnfarrell/pandastable</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>pandastable is not packaged along with py_entitymatching. You can install
pandastable using pip as show below:</p>
<blockquote>
<div>$ pip install pandastable</div></blockquote>
<p>or conda as shown below:</p>
<blockquote class="last">
<div>$ conda install -c dmnfarrell pandastable=0.7.1</div></blockquote>
</div>
<div class="section" id="using-pandastable">
<h5>Using pandastable<a class="headerlink" href="#using-pandastable" title="Permalink to this headline">¶</a></h5>
<p>Pandastable can be easily be used with the wrappers included with py_entitymatching.
The following example shows how:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># import py_entitymatching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Explore the data using pandastable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">data_explore_pandastable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-user_manual/blocking"></span><div class="section" id="specifying-blockers-and-performing-blocking">
<h3>Specifying Blockers and Performing Blocking<a class="headerlink" href="#specifying-blockers-and-performing-blocking" title="Permalink to this headline">¶</a></h3>
<p>In this section, we discuss how you can specify blockers and perform blocking.</p>
<div class="section" id="types-of-blockers-and-blocker-hierarchy">
<h4>Types of Blockers and Blocker Hierarchy<a class="headerlink" href="#types-of-blockers-and-blocker-hierarchy" title="Permalink to this headline">¶</a></h4>
<p>Once the tables are loaded and downsampled, most often you have to do blocking.
Note that by <em>blocking</em> we mean to block a <em>tuple pair</em> from going through to the
matching step. When applied to a tuple pair, a blocker returns <em>True</em> if the pair
should be blocked. You must know conceptually the types of blockers and
the blocker hierarchy in py_entitymatching to extend or modify them based on your need.</p>
<p>There are two types of blockers: (1) tuple-level, and (2) global. A tuple-level blocker
can examine a tuple pair in isolation and decide if it should be admitted to the next
stage. For example, an attribute equivalence blocker is a tuple-level blocker. A global
blocker cannot make this decision in isolation. It would need to examine a set of other
pairs as well. For example, a sorted neighborhood blocker applied over an union of the
input tables is a global blocker. Currently, py_entitymatching supports only
tuple-level blockers.</p>
<p>The blockers can be combined in complex ways, such as</p>
<ul class="simple">
<li>apply blocker <em>b1</em> to the two tables</li>
<li>apply blocker <em>b2</em> to the two tables</li>
<li>apply blocker <em>b3</em> to the output of <em>b1</em></li>
</ul>
<p>Further, you may just want to apply a blocker to just a pair of tuples, to see how
the blocker works.</p>
<p>In py_entitymatching, there is a Blocker class from which a set of concrete blockers
are inherited. These concrete blockers implement the following methods:</p>
<ul class="simple">
<li>block_tables (apply to input tables A and B)</li>
<li>block_candset (apply to an output from another blocker (e.g. table C))</li>
<li>block_tuples (apply to a tuple pair to check if it will survive blocking)</li>
</ul>
<p>In py_entitymatching, there are four concrete blockers implemented: (1) attribute
equivalence blocker, (2) overlap blocker, (3) rule-based blocker, and (4) black box
blocker. All the functions implemented in the concrete blockers are metadata aware.</p>
<p>The class diagram of Blocker and the concrete blockers inherited from it is shown below:</p>
<a class="reference internal image-reference" href="_images/blocker_hierarchy.png"><img alt="'Blocker Hierarchy'" src="_images/blocker_hierarchy.png" style="width: 1162.0px; height: 259.0px;" /></a>
</div>
<div class="section" id="built-in-blockers">
<h4>Built-In Blockers<a class="headerlink" href="#built-in-blockers" title="Permalink to this headline">¶</a></h4>
<p>Built-in blockers are those that have been built into py_entitymatching and you can just
simply call them. py_entitymatching currently offers two built-in blockers.</p>
<p><strong>Attribute Equivalence Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in attribute equivalence blocker
takes an attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that
is, drop the tuple pair) if <cite>x</cite> and <cite>y</cite> are not of the same value.</p>
<p>An example of using the above function is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.AttrEquivalenceBlocker.block_tables" title="py_entitymatching.AttrEquivalenceBlocker.block_tables"><code class="xref py py-meth docutils literal"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>. An example of using
<cite>block_candset</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.AttrEquivalenceBlocker.block_candset" title="py_entitymatching.AttrEquivalenceBlocker.block_candset"><code class="xref py py-meth docutils literal"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.AttrEquivalenceBlocker.block_tuples" title="py_entitymatching.AttrEquivalenceBlocker.block_tuples"><code class="xref py py-meth docutils literal"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
<p><strong>Overlap Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in overlap blocker takes an
attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that is, drop
the tuple pair) if <cite>x</cite> and <cite>y</cite> do not share any token (where the token is a word or
a q-gram).</p>
<p>As part of the pre-processing for this blocker, the strings are first converted to lowercase.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.OverlapBlocker.block_tables" title="py_entitymatching.OverlapBlocker.block_tables"><code class="xref py py-meth docutils literal"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.OverlapBlocker.block_candset" title="py_entitymatching.OverlapBlocker.block_candset"><code class="xref py py-meth docutils literal"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.OverlapBlocker.block_tuples" title="py_entitymatching.OverlapBlocker.block_tuples"><code class="xref py py-meth docutils literal"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
</div>
<div class="section" id="blackbox-blockers">
<h4>Blackbox Blockers<a class="headerlink" href="#blackbox-blockers" title="Permalink to this headline">¶</a></h4>
<p>By <cite>blackbox blockers</cite> we mean that the user supplies a Python function which
encodes blocking for a tuple pair. Specifically, the Python function will take
in two tuples and returns True if the tuple pair needs to be blocked, else
returns False. To use a blackbox blocker, first you must write a
blackbox blocker function.</p>
<p>An example of blackbox blocker function is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that there is a &#39;name&#39; attribute in the input tables</span>
    <span class="c1"># and each value in it has two words</span>
    <span class="n">l_last_name</span> <span class="o">=</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r_last_name</span> <span class="o">=</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">l_last_name</span> <span class="o">!=</span> <span class="n">r_last_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>Then instantiate a <cite>blackbox blocker</cite> and set the blocking function function as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, you can call <cite>block_tables</cite> on the input tables. Conceptually, <cite>block_tables</cite> would
apply the blackbox blocker function on the Cartesian product of the input tables A and B, and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.BlackBoxBlocker.block_tables" title="py_entitymatching.BlackBoxBlocker.block_tables"><code class="xref py py-meth docutils literal"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.BlackBoxBlocker.block_candset" title="py_entitymatching.BlackBoxBlocker.block_candset"><code class="xref py py-meth docutils literal"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>Further, <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.BlackBoxBlocker.block_tuples" title="py_entitymatching.BlackBoxBlocker.block_tuples"><code class="xref py py-meth docutils literal"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
</div>
<div class="section" id="rule-based-blockers">
<h4>Rule-Based Blockers<a class="headerlink" href="#rule-based-blockers" title="Permalink to this headline">¶</a></h4>
<p>You can write a few domain specific rules (for blocking purposes) using rule-based blocker.
If you want to write rules, then you must start by defining a set of features.
Each <cite>feature</cite> is a function that when applied to a tuple pair will return a
numeric value. We will discuss how to create a set of features in the section
<a class="reference internal" href="index.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>block_f</cite>. Then you will be able
to instantiate a rule-based blocker and add rules like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>block_f</cite> is a set of features stored as a Dataframe (see section
<a class="reference internal" href="index.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The blocker is then a disjunction of rules.
That is, even if one of the rules return True, then the tuple pair will be blocked.</p>
<p>Once the rules are specified, you can call <cite>block_tables</cite> on the input tables.
Conceptually, <cite>block_tables</cite> would
apply the rule-based blocker function on the Cartesian product of the input tables A and B and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.RuleBasedBlocker.block_tables" title="py_entitymatching.RuleBasedBlocker.block_tables"><code class="xref py py-meth docutils literal"><span class="pre">block_tables()</span></code></a>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.RuleBasedBlocker.block_candset" title="py_entitymatching.RuleBasedBlocker.block_candset"><code class="xref py py-meth docutils literal"><span class="pre">block_candset()</span></code></a>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.RuleBasedBlocker.block_tuples" title="py_entitymatching.RuleBasedBlocker.block_tuples"><code class="xref py py-meth docutils literal"><span class="pre">block_tuples()</span></code></a>
for more details.</p>
</div>
<div class="section" id="combining-multiple-blockers">
<h4>Combining Multiple Blockers<a class="headerlink" href="#combining-multiple-blockers" title="Permalink to this headline">¶</a></h4>
<p>If you use multiple blockers, then you have to combine them to get a
consolidated candidate set. There are many different ways to combine the candidate sets
such as doing union, majority vote, weighted vote, etc. Currently, py_entitymatching
only supports union-based combining.</p>
<p>In py_entitymatching, <cite>combine_blocker_outputs_via_union</cite> is used to do union-based
combining.</p>
<p>An example of using <cite>combine_blocker_outputs_via_union</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">combine_blocker_outputs_via_union</span><span class="p">([</span><span class="n">C</span><span class="p">,</span> <span class="n">E</span><span class="p">])</span>
</pre></div>
</div>
<p>Conceptually, the command takes in a list of blocker outputs (i.e. pandas Dataframes) and
produces a consolidated table. The output table contains the union of tuple pair ids and
other attributes from the input list.</p>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.combine_blocker_outputs_via_union" title="py_entitymatching.combine_blocker_outputs_via_union"><code class="xref py py-meth docutils literal"><span class="pre">combine_blocker_outputs_via_union()</span></code></a>
for more details.</p>
</div>
</div>
<span id="document-user_manual/create_feats_for_blocking"></span><div class="section" id="creating-features-for-blocking">
<span id="label-create-features-blocking"></span><h3>Creating Features for Blocking<a class="headerlink" href="#creating-features-for-blocking" title="Permalink to this headline">¶</a></h3>
<p>Recall that when doing blocking, you can use built-in blockers,
blackbox blockers, or rule-based blockers. For rule-based blockers,
you have to create a set of features. While creating features, you will have to
refer to tokenizers, similarity functions, and attributes of the tables.
Currently, in py_entitymatching, there are two ways to create features:</p>
<ul class="simple">
<li>Automatically generate a set of features (then you can remove or add some more).</li>
<li>Skip the automatic process and generate features manually.</li>
</ul>
<p>Note that features will also be used in the matching process, as we
will discuss later.</p>
<p>If you are interested in just letting the system to automatically
generate a set of features, then please see <a class="reference internal" href="#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a>.</p>
<p>If you want to generate features on your own, please read below.</p>
<div class="section" id="available-tokenizers-and-similarity-functions">
<h4>Available Tokenizers and Similarity Functions<a class="headerlink" href="#available-tokenizers-and-similarity-functions" title="Permalink to this headline">¶</a></h4>
<p>A tokenizer is a function that takes a string and optionally a number
of other arguments, then tokenizes the string and returns a set of tokens.
Currently, the following tokenizers are provided along with <em>py_entitytmatching</em>:</p>
<ul class="simple">
<li>Alphabetic</li>
<li>Alphanumeric</li>
<li>White space</li>
<li>Delimiter based</li>
<li>Qgram based</li>
</ul>
<p>A similarity function takes two arguments (can be strings, numeric values, etc.),
which are typically two attribute values such
as two book titles, then returns an output value which is typically a similarity score
between the two attribute values. Currently, the following similarity functions
are provided along with <em>py_entitytmatching</em>:</p>
<ul class="simple">
<li>Affine</li>
<li>Hamming distance</li>
<li>Jaro</li>
<li>Jaro-Winkler</li>
<li>Levenshtein</li>
<li>Monge-Elkan</li>
<li>Needleman-Wunsch</li>
<li>Smith-Waterman</li>
<li>Jaccard</li>
<li>Cosine</li>
<li>Dice</li>
<li>Overlap coefficient</li>
<li>Exact match</li>
<li>Absolute norm</li>
</ul>
</div>
<div class="section" id="obtaining-tokenizers-and-similarity-functions">
<h4>Obtaining Tokenizers and Similarity Functions<a class="headerlink" href="#obtaining-tokenizers-and-similarity-functions" title="Permalink to this headline">¶</a></h4>
<p>First you need to get tokenizers and similarity functions to refer them in features.
In py_entitymatching, you can use
<cite>get_tokenizers_for_blocking</cite> to get all the tokenizers available for blocking purposes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above, <cite>block_t</cite> is a dictionary where keys are tokenizer names
and values are tokenizer functions in Python. You can inspect <cite>block_t</cite> and delete/add
tokenizers as appropriate. The above command will return single-argument tokenizers,
i.e., those that take a string then produce a set of tokens.</p>
<p>Each of the keys of the default dictionary returned to ‘block_t’ by
‘get_tokenizers_for_blocking’ represent a tokenizer that can be used by similarity
functions. The keys and the respective tokenizer they represent are shown below:</p>
<ul class="simple">
<li>alphabetic: Alphabetic tokenizer</li>
<li>alphanumeric: Alphanumeric tokenizer</li>
<li>dlm_dc0: Delimiter tokenizer using spaces as the delimiter</li>
<li>qgm_2: Two Gram tokenizer</li>
<li>qgm_3: Three Gram tokenizer</li>
<li>wspace: Whitespace tokenizer</li>
</ul>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.get_tokenizers_for_blocking" title="py_entitymatching.get_tokenizers_for_blocking"><code class="xref py py-meth docutils literal"><span class="pre">get_tokenizers_for_blocking()</span></code></a>
for more details.</p>
<p>Similarly, the user can use <cite>get_sim_funs_for_blocking</cite> to get all the similarity
functions available for blocking purposes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above, <cite>block_s</cite> is a dictionary where keys are similarity function names
and values are similarity functions in Python. Similar to <cite>block_t</cite>, you can
inspect <cite>block_s</cite> and delete/add similarity functions as appropriate.</p>
<p>Each of the keys of the default dictionary returned to ‘block_s’ by
‘get_sim_funs_for_blocking’ represent a similarity function. The keys and the
respective similarity function they represent are shown below:</p>
<ul class="simple">
<li>abs_norm: Absolute Norm</li>
<li>affine: Affine Transformation</li>
<li>cosine: Cosine Similarity</li>
<li>dice: Dice similarity Coefficient</li>
<li>exact_match: Exact Match</li>
<li>hamming_dist: Hamming Distance</li>
<li>hamming_sim: Hamming Similarity</li>
<li>jaccard: Jaccard Similarity</li>
<li>jaro: Jaro Distance</li>
<li>jaro_winkler: Jaro-Winkler Distance</li>
<li>lev_dist: Levenshtein Distance</li>
<li>lev_sim: Levenshtein Similarity</li>
<li>monge_elkan: Monge-Elkan Algorithm</li>
<li>needleman_wunsch: Needleman-Wunsch Algorithm</li>
<li>overlap_coeff: Overlap Coefficient</li>
<li>rel_diff: Relative Difference</li>
<li>smith_waterman: Smith-Waterman Algorithm</li>
</ul>
<p>Please look at the API reference of <a class="reference internal" href="index.html#py_entitymatching.get_sim_funs_for_blocking" title="py_entitymatching.get_sim_funs_for_blocking"><code class="xref py py-meth docutils literal"><span class="pre">get_sim_funs_for_blocking()</span></code></a>
for more details.</p>
</div>
<div class="section" id="obtaining-attribute-types-and-correspondences">
<h4>Obtaining Attribute Types and Correspondences<a class="headerlink" href="#obtaining-attribute-types-and-correspondences" title="Permalink to this headline">¶</a></h4>
<p>In the next step, you need to obtain type and correspondence information about A and B
so that the features can be generated.</p>
<p>First, you need to obtain the types of attributes in A and B,
so that the right tokenizers/similarity functions can be applied to each of them.
In py_entitymatching, you can use <cite>get_attr_types</cite> to get the attribute types.
An example of using <cite>get_attr_types</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>atypes1</cite> and <cite>atypes2</cite> are dictionaries. They contain, the type of
attribute in each of the tables. Note that this <cite>type</cite> is different from basic
Python types. Please look at the API reference of
<a class="reference internal" href="index.html#py_entitymatching.get_attr_types" title="py_entitymatching.get_attr_types"><code class="xref py py-meth docutils literal"><span class="pre">get_attr_types()</span></code></a> for more details.</p>
<p>Next, we need to obtain correspondences between the attributes of A and B,
so that the features can be generated based on those correspondences.
In py_entitymatching, you can use <cite>get_attr_corres</cite> to get the attribute
correspondences.</p>
<p>An example of using <cite>get_attr_corres</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>block_c</cite> is a dictionary containing attribute correspondences.
Currently, py_entitymatching returns attribute correspondences only based on the exact
match of attribute names. You can inspect <cite>block_c</cite> and modify the attribute
correspondences. Please look at the API reference of
<a class="reference internal" href="index.html#py_entitymatching.get_attr_corres" title="py_entitymatching.get_attr_corres"><code class="xref py py-meth docutils literal"><span class="pre">get_attr_corres()</span></code></a> for more details.</p>
</div>
<div class="section" id="getting-a-set-of-features">
<span id="label-get-a-set-of-features-manual"></span><h4>Getting a Set of Features<a class="headerlink" href="#getting-a-set-of-features" title="Permalink to this headline">¶</a></h4>
<p>Recall that so far we have obtained:</p>
<ul class="simple">
<li>block_t, the set of tokenizers,</li>
<li>block_s, the set of sim functions</li>
<li>atypes1 and atypes2, the types of attributes in A and B</li>
<li>block_c, the correspondences of attributes in A and B</li>
</ul>
<p>Next, to obtain a set of features, you can use <cite>get_features</cite> command.
An example of using <cite>get_features</cite> command is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Briefly, this function will go through the correspondences. For each
correspondence <cite>m</cite>, it examines the types of the involved attributes,
then apply the appropriate tokenizers and similarity functions to generate
all appropriate features for this correspondence. The features are returned as
a Dataframe. Please look at the API reference of
<a class="reference internal" href="index.html#py_entitymatching.get_features" title="py_entitymatching.get_features"><code class="xref py py-meth docutils literal"><span class="pre">get_features()</span></code></a> for more details.</p>
</div>
<div class="section" id="adding-removing-features">
<span id="label-add-remove-features"></span><h4>Adding/Removing Features<a class="headerlink" href="#adding-removing-features" title="Permalink to this headline">¶</a></h4>
<p>Given the set of features <cite>block_f</cite> as a pandas Dataframe, you can delete certain features,
add new features.</p>
<p>Deletion of a feature is straightforward, all that you have to do is delete the row
from the feature table corresponding to the feature. You can use <cite>drop</cite> command
from pandas Dataframe for this purpose. Please look at this
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop.html">API reference link</a>
for more details.</p>
<p>There are two ways to create and add a feature: (1) write a blackbox function and
add it to feature table, and (2) define a feature declartively and add it to
feature table.</p>
<p><strong>Adding a Blackbox Function as Feature</strong></p>
<p>To create and add a blackbox function as a feature, first you must define it. Specifically,
the function must take in two tuples as input and return a numeric value. An example of
a blackbox function is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
    <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Then add it to the feature table <cite>block_f</cite> using <cite>add_blackbox_feature</cite> like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of
<a class="reference internal" href="index.html#py_entitymatching.add_blackbox_feature" title="py_entitymatching.add_blackbox_feature"><code class="xref py py-meth docutils literal"><span class="pre">add_blackbox_feature()</span></code></a> for more details.</p>
<p><strong>Adding a Feature Declaratively</strong></p>
<p>Another way to add features is to write a feature expression in
a <cite>declarative</cite> way. py_entitymatching will then compile it into a feature. For
example, you can declaratively create and add a feature like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple[&quot;name&quot;]), qgm_3(rtuple[&quot;name&quot;]))&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <cite>block_t</cite> and <cite>block_s</cite> refer to the dictionaries containing a set of
tokenizers and similarity functions for blocking. Additionally, ‘jaccard’ refers
to the key in ‘block_s’ that represents the Jaccard Similarity function and
‘qgm_3’ refers to the key in ‘block_t’ that represents a three gram tokenizer.
The keys in ‘block_t’ and ‘block_s’ and which function or tokenizer they
represent are explained above in the Obtaining Tokenizers and Similarity Functions
section.</p>
<p>Conceptually, the first command, <cite>get_feature_fn</cite>, creates a feature which is a Python function
that will take two tuples <cite>ltuple</cite> and <cite>rtuple</cite>, get the attribute publisher from <cite>ltuple</cite>,
issuer from <cite>rtuple</cite>, tokenize them, then compute jaccard score.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The feature must refer the tuple from the left table (say A) as <strong>ltuple</strong> and
the tuple from the right table (say B) as <strong>rtuple</strong>.</p>
</div>
<p>The second command, <cite>add_feature</cite> tags the feature with the specified name,
and adds it to the feature table.</p>
<p>As described, the feature that was just created is <em>independent</em> of any table
(eg A and B). Instead, it expects as the input two tuples: ltuple and rtuple.</p>
<p>You can also create more complex features. Specifically,
you are allowed to define arbitrary complex expression involving function names from
<cite>block_t</cite> and <cite>block_s</cite>, and attribute names from ltuple and rtuple.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.address + ltuple.zipcode), qgm_3(rtuple.address + rtuple.zipcode)&#39;</span><span class="p">,</span><span class="n">block_t</span><span class="p">,</span><span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;full_address_address_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also create your own similarity functions and tokenizers for your custom features.
For example, you can create a similarity function that changes all strings to lowercase
before checking if they are equivalent.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This similarity function converts the two strings to lowercase before checking if they are an exact match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_lowercase</span><span class="p">(</span><span class="n">l_attr</span><span class="p">,</span> <span class="n">r_attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">l_attr</span> <span class="o">=</span> <span class="n">l_attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">r_attr</span> <span class="o">=</span> <span class="n">r_attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>You can then add a feature declarativly with your new similarity function.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The new similarity function is added to block_s and then a new feature is created</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span><span class="p">[</span><span class="s1">&#39;match_lowercase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_lowercase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;match_lowercase(ltuple[&quot;name&quot;], rtuple[&quot;name&quot;])&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_match_lowercase&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to create features with your own similarity functions that require
tokenizers. The next example shows how to create a custom tokenizer that returns only
the first and last words of a string.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This custom tokenizer returns the first and last words of a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first_last_tok</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">all_toks</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">toks</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_toks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_toks</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">all_toks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">toks</span>
</pre></div>
</div>
<p>Next, a similarity function that can utilize the new tokenizer is created. This example
shows how to create a similarity function that raises the score if the first words match
and raises the score by one if the second words match.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This similarity function compares two tokens from each set.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Greater weight is placed on the equality of the first token.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first_last_sim</span><span class="p">(</span><span class="n">l_attr</span><span class="p">,</span> <span class="n">r_attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">score</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">score</span> <span class="o">+=</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">score</span>
</pre></div>
</div>
<p>Finally, with the tokenizer and similarity functions defined, the new feature can be
created and added.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The new tokenizer is added to block_t and the new similarity function is added to block_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># then a new feature is created</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span><span class="p">[</span><span class="s1">&#39;first_last_tok&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_last_tok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span><span class="p">[</span><span class="s1">&#39;first_last_sim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_last_sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;first_last_sim(first_last_tok(ltuple[&quot;name&quot;]), first_last_tok(rtuple[&quot;name&quot;]))&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                 <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_fls_flt_flt&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of
<a class="reference internal" href="index.html#py_entitymatching.get_feature_fn" title="py_entitymatching.get_feature_fn"><code class="xref py py-meth docutils literal"><span class="pre">get_feature_fn()</span></code></a> and <a class="reference internal" href="index.html#py_entitymatching.add_feature" title="py_entitymatching.add_feature"><code class="xref py py-meth docutils literal"><span class="pre">add_feature()</span></code></a>
for more details.</p>
</div>
<div class="section" id="summary-of-the-manual-feature-generation-process">
<h4>Summary of the Manual Feature Generation Process<a class="headerlink" href="#summary-of-the-manual-feature-generation-process" title="Permalink to this headline">¶</a></h4>
<p>Here is the summary of commands for the entire manual feature generation process.</p>
<p>To generate features, you must execute the following commands:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <cite>block_f</cite> points to a Dataframe containing features as rows.</p>
</div>
<div class="section" id="ways-to-edit-the-manual-feature-generation-process">
<h4>Ways to Edit the Manual Feature Generation Process<a class="headerlink" href="#ways-to-edit-the-manual-feature-generation-process" title="Permalink to this headline">¶</a></h4>
<p>Here is the summary of ways to edit the variables used in feature generation process.</p>
<ul>
<li><p class="first">The <cite>block_t</cite>, <cite>block_s</cite>, <cite>atypes1</cite>, <cite>atypes2</cite>, <cite>block_c</cite> are dictionaries. You
can modify these variables based on your need, to add/remove tokenizers,
similarity functions, attribute correspondences, etc.</p>
</li>
<li><p class="first"><cite>block_f</cite> is a Dataframe. You can remove a feature by just deleting the corresponding
tuple from the Dataframe.</p>
</li>
<li><p class="first">There are two ways to create and add a feature: (1) write a blackbox function and
add it to feature table, and (2) define the feature declartively and add it to
feature table.
To add a blackbox feature, first write a blackbox function like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
    <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Then add it to the table <cite>block_f</cite> using <cite>add_blackbox_feature</cite> like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
<p>To add a feature declaratively, first write a feature expression and compile it to feature
using <cite>get_feature_fn</cite> like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.address + ltuple.zipcode), qgm_3(rtuple.address + rtuple.zipcode)&#39;</span><span class="p">,</span><span class="n">block_t</span><span class="p">,</span><span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Then add it to the table <cite>block_f</cite> using <cite>add_feature</cite> like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;full_address_address_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="generating-features-automatically">
<span id="label-gen-feats-automatically"></span><h4>Generating Features Automatically<a class="headerlink" href="#generating-features-automatically" title="Permalink to this headline">¶</a></h4>
<p>Recall that to get the features for blocking, eventually you
must execute the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>atypes1</cite>/<cite>atypes2</cite> are the attribute types of A and B, <cite>block_c</cite> is
the correspondences between their attributes, <cite>block_t</cite> is the set of tokenizers,
and <cite>block_s</cite> is the set of similarity functions.</p>
<p>If you don’t want to go through the hassle of creating these intermediate
variables, then you can execute the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>The system will automatically generate a set of features and return it as
as a Dataframe which you can then use for blocking purposes. This Dataframe
contains a few attributes that require further explanation, specifically
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, and ‘simfunction’. There are
two types of similarity functions, those that use tokenizers and those that
do not. Some similarity functions use tokenizers and all such features must
designate a tokenizer for both the left table attribute in
‘left_attr_tokenizer’ and for the right table attribute in
‘right_attr_tokenizer’. The ‘simfunction’ attribute refers to the name of
the function and comes from the keys in ‘block_s’. The various keys and the
actual functions they correspond to are explained in the Obtaining
Tokenizers and Similarity Functions section above.</p>
<p>The command <cite>get_features_for_blocking</cite> will set the following variables: <cite>_block_t</cite>,
<cite>_block_s</cite>, <cite>_atypes1</cite>, <cite>_atypes2</cite>, and <cite>_block_c</cite>. You can access these variables like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_c</span>
</pre></div>
</div>
<p>You can examine these variables, modify them as appropriate, and
then perhaps re-generate the set of features using <cite>get_features</cite> command.</p>
<p>Please look at the API reference of
<a class="reference internal" href="index.html#py_entitymatching.get_features_for_blocking" title="py_entitymatching.get_features_for_blocking"><code class="xref py py-meth docutils literal"><span class="pre">get_features_for_blocking()</span></code></a> for more details.</p>
</div>
</div>
<span id="document-user_manual/debugging_blocking"></span><div class="section" id="debugging-blocking">
<h3>Debugging Blocking<a class="headerlink" href="#debugging-blocking" title="Permalink to this headline">¶</a></h3>
<p>In a typical entity matching workflow, you will load in the two tables to
match, sample them (if required) and use a blocker to remove obvious non-matches.
But it is often not clear whether the blocker drops only non-matches or it
also removes a lot of potential matches.</p>
<p>In such cases, it is important to debug the output of blocker. In
py_entitymatching, <cite>debug_blocker</cite> command can be used for that purpose.</p>
<p>The <cite>debug_blocker</cite> command takes in two input tables A, B, blocker output C
and returns a table D containing a set of tuple pairs that are
potential matches and yet are not present in the blocker output
C. Table D also contains similarity measure computed for each reported
tuple pair (as its second column).</p>
<p>You can examine these potential matches in table D. If you
find that many of them are indeed true matches, then that means the
blocker may have removed too many true matches. In this case you
may want to <cite>relax</cite> the blocker by modifying its parameters, or
choose a different blocker. On the other hand, if you do not
find many true matches in table D, then it could be the case that the
blocker has done a good job and preserve all the matches (or most of
the matches) in the blocker output C.</p>
<p>In the <cite>debug_blocker</cite>, you can optionally specify attribute correspondences between
the input tables A and B. If it is not specified, then attribute correspondences
will be a list of attribute pairs with the exact same names in A and B.</p>
<p>The debugger will use only the attributes mentioned in these attribute
correspondences to try to find potentially matching pairs and place
those pairs into D. Thus, our recommendation is that (a) if the tables
have idential schemas or share a lot of attributes with the same
names, then do not specify the attribute correspondences, in this
case the debugger will use all the attributes with the same name between the two
schemas, (b) otherwise think about what attribute pairs you want to see the
debugger use, then specify those as attribute correspondences.</p>
<p>An example of using <cite>debug_blocker</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corres</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span><span class="s1">&#39;ssn&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;ename&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">),(</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">attr_corres</span><span class="o">=</span><span class="n">corres</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.debug_blocker" title="py_entitymatching.debug_blocker"><code class="xref py py-meth docutils literal"><span class="pre">debug_blocker()</span></code></a>
for more details.</p>
</div>
<span id="document-user_manual/sampling"></span><div class="section" id="sampling">
<span id="label-sampling"></span><h3>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h3>
<p>If you have to use supervised learning-based matchers or evaluate matchers, you need to
create labeled data. To create labeled data, first you need to sample of candidate set
pairs and then label them.</p>
<p>In <em>py_stringmatching</em>, you can use <cite>sample_table</cite> to get a sample. The command does
uniform random sampling without replacement. An example of using <cite>sample_table</cite> is shown
below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">sample_table</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>The command will first create a copy of the input table, sample the specified number of
tuple pairs from the copy, update the metadata and return the sampled table.</p>
<p>For more details, please look into the API reference of <a class="reference internal" href="index.html#py_entitymatching.sample_table" title="py_entitymatching.sample_table"><code class="xref py py-meth docutils literal"><span class="pre">sample_table()</span></code></a></p>
</div>
<span id="document-user_manual/labeling"></span><div class="section" id="labeling">
<h3>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h3>
<p>The command <cite>label_table</cite> can be used to label the samples (see section
<a class="reference internal" href="index.html#label-sampling"><span class="std std-ref">Sampling</span></a>). An example of using <cite>label_table</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">label_table</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">label_column_name</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above command will first create a copy of the input table <cite>S</cite>, update
the metadata, add a column with the
specified column name (in <cite>label_col_name</cite> parameter) fill it with 0 (i.e non-matches)
and open a GUI for you to update the labels. You must specify 0 for non-matches and
1 for matches. Once you close the GUI, the updated table will be returned.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.label_table" title="py_entitymatching.label_table"><code class="xref py py-meth docutils literal"><span class="pre">label_table()</span></code></a>
for more details.</p>
<div class="section" id="new-tool-for-labeling-experimental">
<h4>New tool for labeling (experimental)<a class="headerlink" href="#new-tool-for-labeling-experimental" title="Permalink to this headline">¶</a></h4>
<p>WARNING: The new labeler is only available in python version 3.5 and above only.</p>
<p>A new command <cite>new_label_table</cite> has been added to label the samples. This new
labeler is currently in pre-alpha stage and is still incomplete. Use at your
own risk. An example use is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">new_label_table</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">label_column_name</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The new labeler completes the same task as <cite>label_table</cite> in that it will take
an input table <cite>S</cite> with pairs of tuples and create a copy table <cite>G</cite> with
additional label, comment, and tags columns. The command will open a GUI that
allows the user to label each pair of tuples with with either ‘Yes’, ‘No’, or
‘Not-Sure’.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.new_label_table" title="py_entitymatching.new_label_table"><code class="xref py py-meth docutils literal"><span class="pre">new_label_table()</span></code></a>
for more details</p>
</div>
</div>
<span id="document-user_manual/split_train_test"></span><div class="section" id="splitting-labeled-data-into-training-and-testing-sets">
<h3>Splitting Labeled Data into Training and Testing Sets<a class="headerlink" href="#splitting-labeled-data-into-training-and-testing-sets" title="Permalink to this headline">¶</a></h3>
<p>While doing entity matching you will have to split data for
multiple purposes. Some examples are:</p>
<p>1. Split labeled data into development and test. Th development
set is used to come up with right features for learning-based matcher, and
<cite>test</cite> set is used to evaluate the matcher.</p>
<p>2. Split feature vectors into a train and test set. The train
set is used to train the learning-based matcher and test set is used
for evaluation.</p>
<p>py_entitymatching provides <cite>split_train_test</cite> command for the above need.
An example of using <cite>split_train_test</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">train_proportion</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>split_train_test</cite> returns a dictionary with two keys: train, and test.
The value for the key <cite>train</cite> is a Dataframe containing tuples
allocated from the input table based on train_proportion.
Similarly, the value for the key <cite>test</cite> is a Dataframe containing
tuples for evaluation. An example of getting train and test Dataframes from the output
of <cite>split_train_test</cite> command is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">devel_set</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_set</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Setting the value for train proportion would depend on the
context of its use. For instance, if the data is split for machine learning
purposes then train proportion is typically larger than the
test.
The most commonly used values of train_proportion are between
0.5 and 0.8.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.split_train_test" title="py_entitymatching.split_train_test"><code class="xref py py-meth docutils literal"><span class="pre">split_train_test()</span></code></a> for
more details.</p>
</div>
<span id="document-user_manual/create_feats_for_matching"></span><div class="section" id="creating-features-for-matching">
<span id="label-create-feats-matching"></span><h3>Creating Features for Matching<a class="headerlink" href="#creating-features-for-matching" title="Permalink to this headline">¶</a></h3>
<p>If you have to use supervised learning-based matchers, then you cannot just operate on the
labeled set of tuple pairs. For each tuple in the labeled, you need to convert it
into a feature vector which consists of a list of numerical/categorical features. To do
this, first we need to create a set of features.</p>
<p>There are two ways to create features:</p>
<ul class="simple">
<li>Automatically create a set of features (then the user can remove or add some more).</li>
<li>Skip the automatic process and generate features manually.</li>
</ul>
<div class="section" id="creating-the-features-manually">
<h4>Creating the Features Manually<a class="headerlink" href="#creating-the-features-manually" title="Permalink to this headline">¶</a></h4>
<p>This is very similar to manual feature creation process for blocking (see section
<a class="reference internal" href="index.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>) except the features are created for
matching purposes.
In brief, you can execute the following sequence of commands in py_entitymatching
to create the features manually:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes1 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes2 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atype2</span><span class="p">,</span> <span class="n">match_c</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Further, you can add or delete features as see saw in section
<a class="reference internal" href="index.html#label-add-remove-features"><span class="std std-ref">Adding/Removing Features</span></a>.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.get_tokenizers_for_matching" title="py_entitymatching.get_tokenizers_for_matching"><code class="xref py py-meth docutils literal"><span class="pre">get_tokenizers_for_matching()</span></code></a>
and <a class="reference internal" href="index.html#py_entitymatching.get_sim_funs_for_matching" title="py_entitymatching.get_sim_funs_for_matching"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code></a> for more details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, py_entitymatching returns the same set of features for blocking and matching purposes.</p>
</div>
</div>
<div class="section" id="creating-the-features-automatically">
<h4>Creating the Features Automatically<a class="headerlink" href="#creating-the-features-automatically" title="Permalink to this headline">¶</a></h4>
<p>If you do not want to go through the hassle of creating the features manually, then
the user can generate the features automatically. This is very similar to automatic
feature creation process for blocking (see section <a class="reference internal" href="index.html#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a>).</p>
<p>In py_entitymatching, you can use <cite>get_features_for_matching</cite> to generate features
for matching purposes automatically. An example of using <cite>get_features_for_matching</cite> is
shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>Similar to what we saw in section <a class="reference internal" href="index.html#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a> for blocking, the
command will set the following variables: <cite>_match_t</cite>, <cite>_match_s</cite>, <cite>_atypes1</cite>, <cite>_atypes2</cite>, <cite>_match_c</cite>
and they can be accessed like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_c</span>
</pre></div>
</div>
<p>You can to examine these variables, modify them as appropriate, and then
perhaps regenerate a set of features.
Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.get_features_for_matching" title="py_entitymatching.get_features_for_matching"><code class="xref py py-meth docutils literal"><span class="pre">get_features_for_matching()</span></code></a>
for more details.</p>
</div>
</div>
<span id="document-user_manual/extract_feat_vecs"></span><div class="section" id="extracting-feature-vectors">
<h3>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h3>
<p>Once you have created a set of features, you use them to convert labeled sample to feature
vectors. In py_entitymatching, you can use <cite>extract_feature_vecs</cite> to convert
labeled sample to feature vectors using the features created
(see section <a class="reference internal" href="index.html#label-create-feats-matching"><span class="std std-ref">Creating Features for Matching</span></a>).</p>
<p>An example of using <cite>extract_feature_vecs</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feature_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_before</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">],</span> <span class="n">attrs_after</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Conceptually, the command takes the labeled data (<cite>G</cite>), applies the feature functions (in <cite>match_f</cite>)
to each tuple in G to create a Dataframe, adds the <cite>attrs_before</cite> and <cite>attrs_after</cite>
columns, updates the metadata and returns the resulting Dataframe.</p>
<p>If there is one (or several columns) in labeled data that contains the labels, then those need
to be explicitly specified in <cite>attrs_after</cite>, if you want them them to copy over.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.extract_feature_vecs" title="py_entitymatching.extract_feature_vecs"><code class="xref py py-meth docutils literal"><span class="pre">extract_feature_vecs()</span></code></a>
for more details.</p>
</div>
<span id="document-user_manual/imputing_missing_values"></span><div class="section" id="imputing-missing-values">
<h3>Imputing Missing Values<a class="headerlink" href="#imputing-missing-values" title="Permalink to this headline">¶</a></h3>
<p>While doing supoervised learning-based matching, you would need to create labeled sample,
convert the sample into table of feature vectors, fill in the missing values, select
a machine learning (ML) model and use it to produce matches.</p>
<p>The step of filling in the missing values (also called imputing
missing values) is important and necessary. If there are missing values in the input
tables A and B, then they would be passed on to candidate set and most
likely to the feature vectors. In py_entitymatching, if the feature vectors
contain missing values, then most of the ML algorithms would not work
as they rely on scikit-learn package to provide ML-algorithm
implementations (and their implementations would not work if the
feature vectors contain NaN’s).</p>
<p>To avoid missing value problem in the feature vectors, you must impute the values
of the NaN’s. There are many different ways to impute missing values such as
filling the NaN’s (in the whole table or just some columns) with a constant value,
or fill the NaN’s with an aggregate value (mean, median, etc.).</p>
<p>Since the table is represented as a pandas Dataframe, there are two common ways to impute
missing values: (1) use <cite>fillna</cite> method from pandas Dataframe, and (2) impute missing
values using <cite>Imputer</cite> from Scikit-learn package.</p>
<p>But there are two problems that we have to tackle if we have to using the above commands
or objects directly:</p>
<ul class="simple">
<li>They are not metadata aware, so the user has to explicitly take care of it.</li>
<li>The Dataframe type that gets imputed typically contains attributes such as key, foreign
keys to A and B. The user must have to rightly project them out to impute missing
values using aggregates.</li>
</ul>
<p>In py_entitymatching, we propose a hybrid method to impute missing values. To fill NaN’s
with a constant value use <cite>fillna</cite> command from pandas Dataframe. Please look at the
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.fillna.html">API reference of fillna</a>
for more details. An example of using <cite>fillna</cite> to the whole table is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>H</cite> is a Dataframe containing feature vectors, 0 is the constant value that
to be filled in, and <cite>inplace=True</cite> means that the updation should be done in place
(i.e., without creating a copy). It is important to set <cite>inplace=True</cite> as we do not want
the metadata for H in Catalog to be corrupted.</p>
<p>Another example of using <cite>fillna</cite> on a column is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">[</span><span class="s1">&#39;name_name_lev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="s1">&#39;name_name_lev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that, in the above <cite>inplace</cite> should be specified as False, this is because
the output is getting assigned to a column in the old Dataframe <cite>H</cite> and the metadata
of <cite>H</cite> does not get affected.</p>
<p>To fill NaN’s with an aggregate value, in py_entitymatching you can use <cite>impute_table</cite>
command. It is a wrapper around scikit-learn’s <cite>Imputer</cite> object (to make it metadata aware).
An example of using <cite>impute_table</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">impute_table</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If all the values in a column or a row are NaN’s, then the above aggregation
strategy will not work (i.e. we cannot compute the mean and use it to fill the
missing values). In such cases, you need to specify a value in <cite>val_all_nans</cite>
parameter and the command will use this value to fill in all the missing values.</p>
</div>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.impute_table" title="py_entitymatching.impute_table"><code class="xref py py-meth docutils literal"><span class="pre">impute_table()</span></code></a> for
more details.</p>
</div>
<span id="document-user_manual/matching"></span><div class="section" id="specifying-matchers-and-performing-matching">
<h3>Specifying Matchers and Performing Matching<a class="headerlink" href="#specifying-matchers-and-performing-matching" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ml-matchers">
<h4>ML-Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h4>
<p>Once yor convert the labeled sample  into a table of feature vectors (and their
labels), the we can  can create and apply matchers to the feature vectors.
Currently py_entitymatching supports only ML-based matchers. Implementation wise,
a Matcher is defined as a Python class with certain methods (and some common
utility functions) and all concrete blockers inherit from this Matcher class and
override the methods. Specifically, each concrete matcher will implement at least
the following methods:</p>
<ul class="simple">
<li>fit (for training)</li>
<li>predict (for prediction)</li>
</ul>
<div class="section" id="creating-learning-based-matchers">
<h5>Creating Learning-Based Matchers<a class="headerlink" href="#creating-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>In py_entitymatching, there are seven concrete ML-matchers implemented: (1) naive bayes,
(2) logistic regression, (3) linear regression, (4) support vector machine, (5) decision
trees, (6) random forest, and (7) xgboost matcher.</p>
<p>These concrete matchers are just wrappers of scikit-learn matchers or that supports
scikit-learn wrappers (for eg., xgboost) and this is because
the fit/predict methods in scikit-learn are not metadata aware. The concrete matchers
make the scikit-learn matchers metadata aware.</p>
<p>Each matcher can be created by calling its constructor. Since these matchers are
just the wrappers of scikit-learn matchers, the parameters that can be given to
scikit-learn matchers can be to given to the matchers in py_entitymatching.
For example, a user can create a Decision Tree matcher like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to <a class="reference internal" href="index.html#py_entitymatching.DTMatcher" title="py_entitymatching.DTMatcher"><code class="xref py py-meth docutils literal"><span class="pre">DTMatcher()</span></code></a>, <a class="reference internal" href="index.html#py_entitymatching.RFMatcher" title="py_entitymatching.RFMatcher"><code class="xref py py-meth docutils literal"><span class="pre">RFMatcher()</span></code></a>,
<a class="reference internal" href="index.html#py_entitymatching.NBMatcher" title="py_entitymatching.NBMatcher"><code class="xref py py-meth docutils literal"><span class="pre">NBMatcher()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">LogisticRegressionMatcher()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">LinearRegressionMatcher()</span></code>, <a class="reference internal" href="index.html#py_entitymatching.SVMMatcher" title="py_entitymatching.SVMMatcher"><code class="xref py py-meth docutils literal"><span class="pre">SVMMatcher()</span></code></a>, and
<a class="reference internal" href="index.html#py_entitymatching.XGBoostMatcher" title="py_entitymatching.XGBoostMatcher"><code class="xref py py-meth docutils literal"><span class="pre">XGBoostMatcher()</span></code></a>
for more details.</p>
</div>
<div class="section" id="training-learning-based-matchers">
<h5>Training Learning-Based Matchers<a class="headerlink" href="#training-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>Once the ML-matcher is instantiated, you can train the matcher using the
<cite>fit</cite> command. An example of using the <cite>fit</cite> command for Decision Tree matcher
is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>There are other variants of <cite>fit</cite> method. As an example, Please refer to
<a class="reference internal" href="index.html#py_entitymatching.DTMatcher.fit" title="py_entitymatching.DTMatcher.fit"><code class="xref py py-meth docutils literal"><span class="pre">fit()</span></code></a> for more details.</p>
</div>
<div class="section" id="applying-learning-based-matchers">
<h5>Applying Learning-Based Matchers<a class="headerlink" href="#applying-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>Once the ML-matcher is trained, you can predict the matches using the
<cite>predict</cite> command. An example of using the <cite>predict</cite> command for Decision Tree matcher
is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">probs_attr</span><span class="o">=</span><span class="s1">&#39;proba&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="go">inplace=True)</span>
</pre></div>
</div>
<p>There are other variants of <cite>predict</cite> method. As an example, Please refer to
<a class="reference internal" href="index.html#py_entitymatching.DTMatcher.predict" title="py_entitymatching.DTMatcher.predict"><code class="xref py py-meth docutils literal"><span class="pre">predict()</span></code></a> for more details.</p>
</div>
</div>
<div class="section" id="rule-based-matchers">
<h4>Rule-Based Matchers<a class="headerlink" href="#rule-based-matchers" title="Permalink to this headline">¶</a></h4>
<p>You can write a few domain specific rules (for matching purposes) using the rule-based
matcher. If you want to write rules, then you must start by defining a set of features.
Each <cite>feature</cite> is a function that when applied to a tuple pair will return a
numeric value. We will discuss how to create a set of features in the section
<span class="xref std std-ref">label-create-features-matching</span>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>match_f</cite>. Then you will be able
to instantiate a rule-based matcher and add rules.</p>
<div class="section" id="adding-and-deleting-rules">
<h5>Adding and Deleting Rules<a class="headerlink" href="#adding-and-deleting-rules" title="Permalink to this headline">¶</a></h5>
<p>Once you have created the features for matching, you can create rules like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BooleanRuleMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>match_f</cite> is a set of features stored as a Dataframe (see section
<span class="xref std std-ref">label-create-features-matching</span>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The matcher is then a disjunction of rules.
That is, even if one of the rules return True, then the tuple pair will be a match.</p>
<p>Rules can also be deleted once they have been added to the matcher:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rule_name</span> <span class="o">=</span> <span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule_1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="n">rule_name</span><span class="p">)</span>
</pre></div>
</div>
<p>The command delete_rule must be given the name of the rule to be deleted. Rule names
and information on rules in a matcher can be found using the following commands:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get a list of rule names</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule_names</span> <span class="o">=</span> <span class="n">brm</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view rule source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get rule fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">get_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="applying-rule-based-matcher">
<h5>Applying Rule-Based Matcher<a class="headerlink" href="#applying-rule-based-matcher" title="Permalink to this headline">¶</a></h5>
<p>Once the rules are specified, you can predict the matches using the
<cite>predict</cite> command. An example of using the <cite>predict</cite> command is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information on the <cite>predict</cite> method, please refer to
<code class="xref py py-meth docutils literal"><span class="pre">predict()</span></code> for more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/select_best_matcher"></span><div class="section" id="selecting-a-ml-matcher">
<h3>Selecting a ML-Matcher<a class="headerlink" href="#selecting-a-ml-matcher" title="Permalink to this headline">¶</a></h3>
<p>Once you have created different concrete ML matchers, then you have to choose one of
them for matching purposes. There are many different criteria by which one can
decide to choose a matcher such as <cite>akaike information criterion</cite>, <cite>bayesian information
criterion</cite>, <cite>k-fold cross validation</cite>, etc. Currently py_entitymatching supports
k-fold cross validation and other approaches are left for future work.</p>
<p>Conceptually, the command to select a matcher would take in the following inputs:</p>
<ul class="simple">
<li>List of ML matchers.</li>
<li>Training data (feature vector).</li>
<li>A column of labels that correspond to the feature vectors in the training data.</li>
<li>Number of folds.</li>
</ul>
<p>And it would produce the following output:</p>
<ul class="simple">
<li>Selected matcher.</li>
<li>Statistics such as mean accuracy of all input matchers.</li>
</ul>
<p>In py_entitymatching, <cite>select_matcher</cite> command addresses the above needs. An
example of using <cite>select_matcher</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">select_matcher</span><span class="p">(</span><span class="n">matchers</span><span class="o">=</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="n">rf</span><span class="p">],</span> <span class="n">table</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above the output, <cite>result</cite> is a dictionary containing three keys: (1) selected_matcher,
(2) cv_stats, and (3) drill_down_cv_stats. <cite>selected_matcher</cite> is the selected ML-based matcher,
<cite>cv_stats</cite> is a Dataframe which includes the average cross validation scores for each matcher
and for each metric, and ‘drill_down_cv_stats’ is a dictionary where each key is a metric that
includes the cross validation statistics for each fold.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.select_matcher" title="py_entitymatching.select_matcher"><code class="xref py py-meth docutils literal"><span class="pre">select_matcher()</span></code></a> for
more details.</p>
</div>
<span id="document-user_manual/debugging_matcher"></span><div class="section" id="debugging-ml-matchers">
<h3>Debugging ML-Matchers<a class="headerlink" href="#debugging-ml-matchers" title="Permalink to this headline">¶</a></h3>
<p>While doing entity matching you would like to choose a matcher that produces the desired
precision, recall or F1 numbers. If a matcher does not produce the desired accuracy, then
you would like to debug the matcher. py_entitymatching supports two ways to
debug: (1) using the GUI, and (2) using the command line.</p>
<div class="section" id="debugging-using-the-gui">
<h4>Debugging Using the GUI<a class="headerlink" href="#debugging-using-the-gui" title="Permalink to this headline">¶</a></h4>
<p>py_entitymatching supports debugging using the GUI for a subset of ML-based matchers.
Specifically, it supports debugging Decision Tree matcher and Random Forest matcher.
You can use <cite>vis_debug_dt</cite> and <cite>vis_debug_rf</cite> to debug Decision Tree matcher
and Random Forest matcher respectively.</p>
<p>An example of using <cite>vis_debug_dt</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">vis_debug_dt</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The command would display a GUI containing evaluation summary and an option to see tuples
flagged as <cite>false positives</cite> or <cite>false negatives</cite>. If you select <cite>false positives</cite>
then false positive tuple pairs would be displayed in the adjoining window. Similarly,
if <cite>false negatives</cite> is selected then false negative tuple pairs would be
displayed. By default, <cite>false positives</cite> is selected.
Each tuple pair is displayed with two buttons: <cite>show</cite> and <cite>debug</cite>. If you click on
<cite>show</cite>, then individual tuples (of that tuple pair) are displayed in a separate window.
If you click on <cite>debug</cite>, then a window with individual tuples and the
path taken by the feature vector in the Decision Tree that leads to the predicted value
is displayed.</p>
<p>The usage of <cite>vis_debug_rf</cite> is same as <cite>vis_debug_dt</cite>. The command would display a GUI
similar to <cite>vis_debug_dt</cite>, except the debug window would list a set of trees. You can
expand each tree to see the path taken by the features in that tree.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.vis_debug_dt" title="py_entitymatching.vis_debug_dt"><code class="xref py py-meth docutils literal"><span class="pre">vis_debug_dt()</span></code></a> and
<a class="reference internal" href="index.html#py_entitymatching.vis_debug_rf" title="py_entitymatching.vis_debug_rf"><code class="xref py py-meth docutils literal"><span class="pre">vis_debug_rf()</span></code></a> for more details.</p>
<p>If you want to debug a Decision Tree matcher or Random Forest matcher using GUI,
then we recommend the following steps:</p>
<ol class="arabic simple">
<li>In the displayed GUI, check precision and recall numbers in evaluation summary.</li>
<li>If the user wants to improve precision, then he/she should choose to see false positives.</li>
<li>If the user wants to improve recall, then he/she should choose to see false negatives.</li>
<li>In the displayed (false positive/false negative) tuple pairs,
you can click on the <cite>show</cite> button to see the tuples from the left and right tables.</li>
<li>In the displayed (false positive/false negative) tuple pairs, you can choose a tuple
and click on the <cite>debug</cite> button to see the detailed evaluation path of that tuple.</li>
<li>Based on the input tuples, predicates at each node and the actual feature value,
you should decide on the next step. Some of the possible next steps are
cleaning  the input data, adding more features, adding more training data, trying a
different matcher, etc.</li>
</ol>
</div>
<div class="section" id="debugging-using-the-command-line">
<h4>Debugging Using the Command Line<a class="headerlink" href="#debugging-using-the-command-line" title="Permalink to this headline">¶</a></h4>
<p>Similar to debugging using the GUI, py_entitymatching supports command line debugging for two
ML matchers: Decision Tree and Random Forest. Currently, py_entitymatching  supports
command line debugging only using tuple pairs, other approaches are left for future work.</p>
<p>You can use <cite>debug_decisiontree_matcher</cite> and <cite>debug_randomforest_matcher</cite> to debug
Decision Tree matcher and Random Forest matcher respectively.</p>
<p>An example of using <cite>debug_decisiontree_matcher</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">debug_decisiontree_matcher</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">match_f</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, the debug command prints the path taken by the feature vector, its
evaluation status at each node and the actual feature value at each node.</p>
<p>The usage of <cite>debug_randomforest_matcher</cite> is same as <cite>debug_decisiontree_matcher</cite>.
Similar to <cite>debug_decisiontree_matcher</cite> command, it prints the path taken by the feature
vector, except that it displays the path taken in each tree of the Random Forest.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.debug_decisiontree_matcher" title="py_entitymatching.debug_decisiontree_matcher"><code class="xref py py-meth docutils literal"><span class="pre">debug_decisiontree_matcher()</span></code></a>
and <a class="reference internal" href="index.html#py_entitymatching.debug_randomforest_matcher" title="py_entitymatching.debug_randomforest_matcher"><code class="xref py py-meth docutils literal"><span class="pre">debug_randomforest_matcher()</span></code></a> for more details.</p>
<p>If you want to debug a Decision Tree matcher or Random
Forest matcher using the command line, then we recommend the following steps:</p>
<ol class="arabic simple">
<li>Evaluate the accuracy of predictions using user created labels. The evaluation can
be done using <a class="reference internal" href="index.html#py_entitymatching.eval_matches" title="py_entitymatching.eval_matches"><code class="xref py py-meth docutils literal"><span class="pre">eval_matches()</span></code></a> command.</li>
<li>If you want to improve precision, then he/she should debug false positives.</li>
<li>If you want to improve recall, then he/she should debug false negatives.</li>
<li>You should then retrieve the tuples from the tuple id pairs listed in evaluation
summary, and debug using the commands described above.</li>
<li>Based on the input tuples, predicates at each node and the actual feature value,
you should decide on the next step. Some of the possible next steps are clean
the input data, add more features, add more training data, try different matcher, etc.</li>
</ol>
</div>
<div class="section" id="impact-of-imputing-missing-values">
<h4>Impact of Imputing Missing Values<a class="headerlink" href="#impact-of-imputing-missing-values" title="Permalink to this headline">¶</a></h4>
<p>You should be aware of the following subtleties as it would
have an impact when he/she imputes values to feature vector set:</p>
<p>1. When you use the GUI for debugging, you would first choose to see
false positives/false negatives and then you would click the <cite>debug</cite> button to debug
that tuple pair. In this case, the feature vector in that row is given as input to find the path
traversed in the Decision Tree. If you had imputed the feature vector set to get
rid of NaN’s, then the imputed values would be considered to find the path traversed.</p>
<p>2. When you use the command line for debugging, then you would first evaluate the
predictions, select false positive or false negative tuple pairs to debug, retrieve the
tuples from the left and right tables and finally give them as input to command line
debugger commands. If you had imputed the feature vector set to get rid of NaN’s (using
a aggregate strategy), then imputed values would not be known to the debugger.</p>
<p>So if the input tables have NaN’s, then the output of the command line debugger would only
be partially correct (i.e., the displayed predicates would be correct, but the predicate
outcome may differ between current tuple pair and the actual feature vector used during
prediction).</p>
</div>
</div>
<span id="document-user_manual/evaluate_matching"></span><div class="section" id="evaluating-the-matching-output">
<h3>Evaluating the Matching Output<a class="headerlink" href="#evaluating-the-matching-output" title="Permalink to this headline">¶</a></h3>
<p>Once you have predicted matches using ML-based matcher, then you would have to
evaluate the matches. py_entitymatching supports <cite>eval_matches</cite> command for that
purpose.</p>
<p>An example of using <cite>eval_matches</cite> command is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>eval_summary</cite> is a dictionary containing accuracy numbers (such as
precision, recall, F1, etc) and the list of false positives/negatives.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.eval_matches" title="py_entitymatching.eval_matches"><code class="xref py py-meth docutils literal"><span class="pre">eval_matches()</span></code></a> for
more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/misc"></span><div class="section" id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<p>This section covers some miscellaneous things in py_entitymatching.</p>
<div class="section" id="csv-format">
<span id="label-csv-format"></span><h3>CSV Format<a class="headerlink" href="#csv-format" title="Permalink to this headline">¶</a></h3>
<p>The CSV format is selected because it’s well known and can be read by numerous external
programs. Further, it can be easily inspected and edited by the users.
You can read more about CSV formats <a class="reference external" href="https://en.wikipedia.org/wiki/Comma-separated_values">here</a>.</p>
<p>There are two common CSV formats that are used to store CSV files: one with attribute
names in the first line, and one without. Both these formats are supported by py_entitymatching.</p>
<p>An example of a CSV file with attribute names is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">birth_year</span><span class="p">,</span> <span class="n">hourly_wage</span><span class="p">,</span> <span class="n">zipcode</span>
<span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94321</span>
</pre></div>
</div>
<p>An example of a CSV file with out attribute names is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94321</span>
</pre></div>
</div>
</div>
<div class="section" id="metadata-file-format">
<h3>Metadata File Format<a class="headerlink" href="#metadata-file-format" title="Permalink to this headline">¶</a></h3>
<p>The CSV file can be accompanied with a metadata file containing the metadata information
of the table. Typically, it contains information such as key, foreign key, etc.
The metadata file is expected to be of the same name as the CSV file but with <cite>.metadata</cite>
extension. For example, if the CSV file <cite>table_A.csv</cite> contains table A’s data, then
<cite>table_A.metadata</cite> will contain table A’s metadata. So, the metadata is
associated based on the names of the files. The metadata file contains key-value pairs
one per line and each line starts with ‘#’.</p>
<p>An example of metadata file is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#key=ID</span>
</pre></div>
</div>
<p>In the above, the pair key=ID states that ID is the key attribute.</p>
</div>
<div class="section" id="writing-a-dataframe-to-disk-along-with-its-metadata">
<h3>Writing a Dataframe to Disk Along With Its Metadata<a class="headerlink" href="#writing-a-dataframe-to-disk-along-with-its-metadata" title="Permalink to this headline">¶</a></h3>
<p>To write a Dataframe to disk along with its metadata, you can use <cite>to_csv_metadata</cite>
command in py_entitymatching. An example of using <cite>to_csv_metadata</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">to_csv_metadata</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;./table_A.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above command will first write Dataframe pointed by <cite>A</cite> to <cite>table_A.csv</cite> file in the
disk (in CSV format), next it will write the metadata of <cite>table A</cite> stored in the Catalog
to <cite>table_A.metadata</cite> file in the disk.</p>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.to_csv_metadata" title="py_entitymatching.to_csv_metadata"><code class="xref py py-meth docutils literal"><span class="pre">to_csv_metadata()</span></code></a> for
more details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Once the Dataframe is written to disk along with metadata, it can read using <a class="reference internal" href="index.html#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal"><span class="pre">read_csv_metadata()</span></code></a> command.</p>
</div>
</div>
<div class="section" id="writing-reading-other-types-of-py-entitymatching-objects">
<h3>Writing/Reading Other Types of py_entitymatching Objects<a class="headerlink" href="#writing-reading-other-types-of-py-entitymatching-objects" title="Permalink to this headline">¶</a></h3>
<p>After creating a blocker or feature table, it is desirable to have a
way to persist the objects to disk for future use. py_entitymatching provides
two commands for that purpose: <cite>save_object</cite> and <cite>load_object</cite>.</p>
<p>An example of using <cite>save_object</cite> is shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">([</span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">],</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_object</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="s1">&#39;./rule_based_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>load_object</cite> loads the stored object from disk. An example of using <cite>load_object</cite> is
shown below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="s1">&#39;./rule_based_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to the API reference of <a class="reference internal" href="index.html#py_entitymatching.save_object" title="py_entitymatching.save_object"><code class="xref py py-meth docutils literal"><span class="pre">save_object()</span></code></a> and
<a class="reference internal" href="index.html#py_entitymatching.save_object" title="py_entitymatching.save_object"><code class="xref py py-meth docutils literal"><span class="pre">save_object()</span></code></a> for more details.</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/overview"></span><div class="section" id="overview-of-command-organization">
<h2>Overview of Command Organization<a class="headerlink" href="#overview-of-command-organization" title="Permalink to this headline">¶</a></h2>
<p>The commands are organized roughly in the order which the user will use to come up with an
entity matching workflow.</p>
</div>
<span id="document-user_manual/api/actual_commands"></span><div class="section" id="commands-in-py-entitymatching">
<h2>Commands in py_entitymatching<a class="headerlink" href="#commands-in-py-entitymatching" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/reading_and_writing_data"></span><div class="section" id="reading-and-writing-data">
<h3>Reading and Writing Data<a class="headerlink" href="#reading-and-writing-data" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.read_csv_metadata">
<code class="descclassname">py_entitymatching.</code><code class="descname">read_csv_metadata</code><span class="sig-paren">(</span><em>file_path</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.read_csv_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a CSV (comma-separated values) file into a pandas DataFrame
and update the catalog with the metadata. The CSV files typically contain
data for the input tables or a candidate set.</p>
<p>Specifically, this function first reads the CSV file from the given file
path into a pandas DataFrame, by using pandas’ in-built ‘read_csv’
method. Then, it updates the catalog with the metadata. There are three
ways to update the metadata: (1) using a metadata file, (2) using the
key-value parameters supplied in the function, and (3) using both
metadata file and key-value parameters.</p>
<p>To update the metadata in the catalog using the metadata file,
the function will look for a file in the same directory with  same file name
but with a  specific extension. This extension can be optionally given by
the user (defaults to ‘.metadata’). If the metadata  file is  present,
the function will read and update the catalog appropriately. If  the
metadata file is not present, the function will issue a warning that the
metadata file is not present.</p>
<p>The metadata information can also be given as parameters to the function
(see description of arguments for more details). If given, the function
will update the catalog with the given information.</p>
<p>Further, the metadata can partly reside in the metdata file and partly as
supplied parameters. The function will take a union of the two and
update the catalog appropriately.
If the same metadata is given in both the metadata file
and the function, then the metadata in the function takes precedence over
the metadata given in the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> (<em>string</em>) – The CSV file path</li>
<li><strong>kwargs</strong> (<em>dictionary</em>) – A Python dictionary containing key-value arguments.
There are a few key-value pairs that are specific to
read_csv_metadata and  all the other key-value pairs are passed
to pandas read_csv method</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A pandas DataFrame read from the input CSV file.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>file_path</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If a file does not exist in the
given <cite>file_path</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p><em>Example 1:</em> Read from CSV file and set metadata</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_file&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"> # &#39;id&#39;</span>
</pre></div>
</div>
<p><em>Example 2:</em>  Read from CSV file (with metadata file in the same directory</p>
<blockquote>
<div><p>Let the metadata file contain the following contents:</p>
<blockquote>
<div>#key = id</div></blockquote>
</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_file&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"> # &#39;id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.to_csv_metadata" title="py_entitymatching.to_csv_metadata"><code class="xref py py-meth docutils literal"><span class="pre">to_csv_metadata()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.to_csv_metadata">
<code class="descclassname">py_entitymatching.</code><code class="descname">to_csv_metadata</code><span class="sig-paren">(</span><em>data_frame</em>, <em>file_path</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.to_csv_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the DataFrame contents to a CSV file and the DataFrame’s metadata
(to a separate text file).</p>
<p>This function writes the DataFrame contents to a CSV file in
the given file path. It uses ‘to_csv’ method from pandas to write
the CSV file. The metadata contents are written to the same directory
derived from the file path but with the different extension. This
extension can be optionally given by the user (with the default value
set to .metadata).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame that should be written to disk.</li>
<li><strong>file_path</strong> (<em>string</em>) – The file path to which the DataFrame contents
should be written. Metadata is written with the same file name
with the extension given by the user (defaults to ‘.metadata’).</li>
<li><strong>kwargs</strong> (<em>dictionary</em>) – A Python dictionary containing key-value pairs.
There is one key-value pair that is specific to
to_csv_metadata: metadata_extn. All the other key-value pairs
are passed to pandas to_csv function.
Here the metadata_extn is the metadata
extension (defaults to ‘.metadata’), with which
the metadata file must be written.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned if the files were written
successfully.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type  pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>file_path</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If DataFrame cannot be written to the given
<cite>file_path</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">to_csv_metadata</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;path_to_csv_file&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.read_csv_metadata" title="py_entitymatching.read_csv_metadata"><code class="xref py py-meth docutils literal"><span class="pre">read_csv_metadata()</span></code></a></p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/loading_and_saving_objects"></span><div class="section" id="loading-and-saving-objects">
<h3>Loading and Saving Objects<a class="headerlink" href="#loading-and-saving-objects" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.load_table">
<code class="descclassname">py_entitymatching.</code><code class="descname">load_table</code><span class="sig-paren">(</span><em>file_path</em>, <em>metadata_ext=’.pklmetadata’</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.load_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a pickled DataFrame from a file along with its metadata.</p>
<p>This function loads a DataFrame from a file stored in pickle format.</p>
<p>Further, this function looks for a metadata file with the same file name
but with an extension given by the user (defaults to ‘.pklmetadata’. If the
metadata file is present, the function will update the metadata for that
DataFrame in the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> (<em>string</em>) – The file path to load the file from.</li>
<li><strong>metadata_ext</strong> (<em>string</em>) – The metadata file extension (defaults to
‘.pklmetadata’) that should be used to generate metadata file name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">If the loading is successful, the function will return a pandas
DataFrame read from the file. The catalog will be updated with the
metadata read from the metadata file (if the file was present).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>file_path</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>metadata_ext</cite> is not of type string.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_table</span><span class="p">(</span><span class="s1">&#39;./A.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_table</span><span class="p">(</span><span class="s1">&#39;./A.pkl&#39;</span><span class="p">,</span> <span class="n">metadata_ext</span><span class="o">=</span><span class="s1">&#39;.pklmeta&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.save_table" title="py_entitymatching.save_table"><code class="xref py py-meth docutils literal"><span class="pre">save_table()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is different from read_csv_metadata in two aspects.
First, this function currently does not support reading in candidate
set tables, where there are more metadata such as ltable,
rtable than just ‘key’, and conceptually the user is expected to
provide ltable and rtable information while calling this function. (
this support will be added shortly). Second, this function loads the
table stored in a pickle format.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.save_table">
<code class="descclassname">py_entitymatching.</code><code class="descname">save_table</code><span class="sig-paren">(</span><em>data_frame</em>, <em>file_path</em>, <em>metadata_ext=’.pklmetadata’</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.save_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a DataFrame to disk along with its metadata in a pickle format.</p>
<p>This function saves a  DataFrame to disk along with its metadata from
the catalog.</p>
<p>Specifically, this function saves the DataFrame in the given
file path, and saves the metadata in the same directory (as the
file path) but with a different extension. This extension can be
optionally given by the user (defaults to ‘.pklmetadata’).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame that should be saved.</li>
<li><strong>file_path</strong> (<em>string</em>) – The file path where the DataFrame must be stored.</li>
<li><strong>metadata_ext</strong> (<em>string</em>) – The metadata extension that should be used while
storing the metadata information. The default value is
‘.pklmetadata’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned if the DataFrame is successfully
saved.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>file_path</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>metadata_ext</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If a file cannot written in the given <cite>file_path</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_table</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;./A.pkl&#39;</span><span class="p">)</span> <span class="c1"># will store two files ./A.pkl and ./A.pklmetadata</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_table</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;./A.pkl&#39;</span><span class="p">,</span> <span class="n">metadata_ext</span><span class="o">=</span><span class="s1">&#39;.pklmeta&#39;</span><span class="p">)</span> <span class="c1"># will store two files ./A.pkl and ./A.pklmeta</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.load_table" title="py_entitymatching.load_table"><code class="xref py py-meth docutils literal"><span class="pre">load_table()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is a bit different from to_csv_metadata, where the
DataFrame is stored in a CSV file format. The CSV file format can be
viewed using a text editor. But a DataFrame stored using ‘save_table’ is
stored in a special format, which cannot be viewed with a text editor.
The reason we have save_table is, for larger DataFrames it is
efficient to pickle the DataFrame to disk than writing the DataFrame
in CSV format.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.load_object">
<code class="descclassname">py_entitymatching.</code><code class="descname">load_object</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.load_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a Python object from disk.</p>
<p>This function loads py_entitymatching objects from disk such as
blockers, matchers, feature table, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file_path</strong> (<em>string</em>) – The file path to load the object from.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Python object read from the file path.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>file_path</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If a file does not exist at the given <cite>file_path</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="s1">&#39;./rule_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">save_object()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.save_object">
<code class="descclassname">py_entitymatching.</code><code class="descname">save_object</code><span class="sig-paren">(</span><em>object_to_save</em>, <em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.save_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a Python object to disk.</p>
<p>This function is intended to be used to save py_entitymatching objects such as
rule-based blocker, feature vectors, etc. A user would like to store
py_entitymatching objects to disk, when he/she wants to save the workflow and
resume it later. This function provides a way to save the required
objects to disk.</p>
<p>This function takes in the object to save the file path. It pickles the object and
stores it in the file path specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>object_to_save</strong> (<em>Python object</em>) – The Python object to save. This can be
a rule-based blocker, feature vectors, etc.</li>
<li><strong>file_path</strong> (<em>string</em>) – The file path where the object must be saved.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned, if the saving was successful.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>file_path</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If a file cannot be written in the given <cite>file_path</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasebBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;colA_colA_lev_dist(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_object</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="s1">&#39;./rule_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">load_object()</span></code></p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/handling_metadata"></span><div class="section" id="handling-metadata">
<span id="label-handling-metadata"></span><h3>Handling Metadata<a class="headerlink" href="#handling-metadata" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.get_catalog">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_catalog</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_catalog" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the catalog information for the current session.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Python dictionary containing the catalog information.<p>Specifically, the dictionary contains the Python identifier of a
DataFrame (obtained by id(DataFrame object)) as the key
and their properties as value.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">catalog</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_catalog</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_catalog_len">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_catalog_len</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_catalog_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the length (i.e the number of entries) in the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The number of entries in the catalog as an integer.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_catalog_len</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.del_catalog">
<code class="descclassname">py_entitymatching.</code><code class="descname">del_catalog</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.del_catalog" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes the catalog for the current session.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Boolean value of True is returned if the deletion was successful.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">del_catalog</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.is_catalog_empty">
<code class="descclassname">py_entitymatching.</code><code class="descname">is_catalog_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.is_catalog_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the catalog is empty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Boolean value of True is returned if the catalog is empty,
else returns False.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_catalog_empty</span><span class="p">()</span>
<span class="go"> # False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.is_dfinfo_present">
<code class="descclassname">py_entitymatching.</code><code class="descname">is_dfinfo_present</code><span class="sig-paren">(</span><em>data_frame</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.is_dfinfo_present" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the DataFrame information is present in the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame that should be checked for its
presence in the catalog.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A Boolean value of True is returned if the DataFrame is present in
the catalog, else False is returned.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type pandas
DataFrame.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_dfinfo_present</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"> # True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.is_property_present_for_df">
<code class="descclassname">py_entitymatching.</code><code class="descname">is_property_present_for_df</code><span class="sig-paren">(</span><em>data_frame</em>, <em>property_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.is_property_present_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the given property is present for the given DataFrame in the
catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the property must be
checked for.</li>
<li><strong>property_name</strong> (<em>string</em>) – The name of the property that should be</li>
<li><strong>for its presence for the DataFrame</strong><strong>, </strong><strong>in the catalog.</strong> (<em>checked</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned if the property is present for
the given DataFrame.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>property_name</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code> – If <cite>data_frame</cite> is not present in the catalog.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_property_present_for_df</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="go"> # True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_property_present_for_df</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;fk_ltable&#39;</span><span class="p">)</span>
<span class="go"> # False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.show_properties">
<code class="descclassname">py_entitymatching.</code><code class="descname">show_properties</code><span class="sig-paren">(</span><em>data_frame</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.show_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the properties for a DataFrame that is present in the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data_frame</strong> (<em>DataFrame</em>) – The input pandas DataFrame for which the
properties must be displayed.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;key_attr&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key_attr&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">show_properties</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># id: 4572922488  # This will change dynamically</span>
<span class="go"># key: key_attr</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.show_properties_for_id">
<code class="descclassname">py_entitymatching.</code><code class="descname">show_properties_for_id</code><span class="sig-paren">(</span><em>object_id</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.show_properties_for_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Shows the properties for an object id present in the catalog.</p>
<p>Specifically, given an object id got from typically executing id(
&lt;object&gt;), where the object could be a DataFrame, this function will
display the properties present for that object id in the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>object_id</strong> (<em>int</em>) – The Python identifier of an object (typically a
pandas DataFrame).</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;key_attr&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key_attr&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">show_properties_for_id</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go"># id: 4572922488  # This will change dynamically</span>
<span class="go"># key: key_attr</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_property">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_property</code><span class="sig-paren">(</span><em>data_frame</em>, <em>property_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the value of a property (with the given property name) for a pandas
DataFrame from the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the property should be
retrieved.</li>
<li><strong>property_name</strong> (<em>string</em>) – The name of the property that should be
retrieved.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Python object (typically a string or a pandas DataFrame depending
on the property name) is returned.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>property_name</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code> – If <cite>data_frame</cite> information is not present in the catalog.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code> – If requested property for the <cite>data_frame</cite> is not present
in the catalog.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="go"> # id</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.set_property">
<code class="descclassname">py_entitymatching.</code><code class="descname">set_property</code><span class="sig-paren">(</span><em>data_frame</em>, <em>property_name</em>, <em>property_value</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the value of a property (with the given property name) for a pandas
DataFrame in the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the property must  be
set.</li>
<li><strong>property_name</strong> (<em>string</em>) – The name of the property to be set.</li>
<li><strong>property_value</strong> (<em>object</em>) – The value of the property to be set. This is
typically a string (such as key) or pandas DataFrame (such as
ltable, rtable).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned if the update was successful.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>property_name</cite> is not of type string.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="go"> # id</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"> # id</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the input DataFrame is not present in the catalog, this function
will create an entry in the catalog and set the given property.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.del_property">
<code class="descclassname">py_entitymatching.</code><code class="descname">del_property</code><span class="sig-paren">(</span><em>data_frame</em>, <em>property_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.del_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a property for a pandas DataFrame from the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which a property must be
deleted from the catalog.</li>
<li><strong>property_name</strong> (<em>string</em>) – The name of the property that should be deleted.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned if the deletion was successful.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>property_name</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code> – If <cite>data_frame</cite> information is not present in the catalog.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code> – If requested property for the DataFrame is not present
in the catalog.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="go"># id</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">del_property</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">is_property_present_for_df</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
<span class="go"># False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.copy_properties">
<code class="descclassname">py_entitymatching.</code><code class="descname">copy_properties</code><span class="sig-paren">(</span><em>source_data_frame</em>, <em>target_data_frame</em>, <em>replace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.copy_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies properties from a source DataFrame to target DataFrame in the
catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_data_frame</strong> (<em>DataFrame</em>) – The DataFrame from which the properties
to be copied from, in the catalog.</li>
<li><strong>target_data_frame</strong> (<em>DataFrame</em>) – The DataFrame to which the properties
to be copied to, in the catalog.</li>
<li><strong>replace</strong> (<em>boolean</em>) – A flag to indicate whether the source
DataFrame’s  properties can replace the target
DataFrame’s properties in the catalog. The default value for the
flag is True.
Specifically, if the target DataFrame’s information is already
present in the catalog then the function will check if the
replace flag is True. If the flag is set to True, then the
function will first delete the existing properties and then set
it with the source DataFrame properties.
If the flag is False, the function will just return without
modifying the existing properties.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned if the copying was successful.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>source_data_frame</cite> is not of
type pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>target_data_frame</cite> is not of
type pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code> – If source DataFrame is not present in the
catalog.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">copy_properties</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go"># &#39;id&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_key">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_key</code><span class="sig-paren">(</span><em>data_frame</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the value of ‘key’ property for a DataFrame from the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the key must be
retrieved from the catalog.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A string value containing the key column name is returned (if present).</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># &#39;id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.set_key">
<code class="descclassname">py_entitymatching.</code><code class="descname">set_key</code><span class="sig-paren">(</span><em>data_frame</em>, <em>key_attribute</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.set_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the value of ‘key’ property for a DataFrame in the catalog with the
given attribute (i.e column name).</p>
<p>Specifically, this function set the the key attribute for the DataFrame
if the given attribute satisfies the following two properties:</p>
<blockquote>
<div><p>The key attribute should have unique values.</p>
<p>The key attribute should not have missing values. A missing value
is represented as np.NaN.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The DataFrame for which the key must be set in
the catalog.</li>
<li><strong>key_attribute</strong> (<em>string</em>) – The key attribute (column name) in the
DataFrame.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned, if the given attribute
satisfies the conditions for a key and the update was successful.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type
pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>key_attribute</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code> – If given <cite>key_attribute</cite> is not in the DataFrame columns.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># &#39;id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_fk_ltable">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_fk_ltable</code><span class="sig-paren">(</span><em>data_frame</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_fk_ltable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the foreign key to left table for a DataFrame from the
catalog.</p>
<p>Specifically this function is a sugar function that will get the foreign
key to left table using underlying <a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal"><span class="pre">get_property()</span></code></a> function.
This function is typically called on a DataFrame which contains metadata
such as fk_ltable, fk_rtable, ltable, rtable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which the foreign key
ltable property must be retrieved.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A Python object, typically a string is returned.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_fk_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_fk_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go"># &#39;ltable_id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.set_fk_ltable">
<code class="descclassname">py_entitymatching.</code><code class="descname">set_fk_ltable</code><span class="sig-paren">(</span><em>data_frame</em>, <em>fk_ltable</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.set_fk_ltable" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the foreign key to ltable for a DataFrame in the catalog.</p>
<p>Specifically this function is a sugar function that will set the foreign
key to the left table using <a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.set_property()</span></code></a> function. This
function is typically called on a DataFrame which contains metadata such as
fk_ltable, fk_rtable, ltable, rtable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which the foreign key
ltable property must be set.</li>
<li><strong>fk_ltable</strong> (<em>string</em>) – The attribute that must ne set as the foreign key
to the ltable in the catalog.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned if the foreign key to ltable was
set successfully.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type
pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>fk_ltable</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>fk_ltable</cite> is not in the input
DataFrame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_fk_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_fk_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go"># &#39;ltable_id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_fk_rtable">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_fk_rtable</code><span class="sig-paren">(</span><em>data_frame</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_fk_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the foreign key to right table for a DataFrame from the catalog.</p>
<p>Specifically this function is a sugar function that will get the foreign
key to right table using <a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_property()</span></code></a> function. This
function is typically called on a DataFrame which contains metadata such as
fk_ltable, fk_rtable, ltable, rtable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which the foreign key
rtable property must be retrieved.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A Python object, (typically a string) is returned.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_fk_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_fk_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go"># &#39;rtable_id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.set_fk_rtable">
<code class="descclassname">py_entitymatching.</code><code class="descname">set_fk_rtable</code><span class="sig-paren">(</span><em>data_frame</em>, <em>foreign_key_rtable</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.set_fk_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the foreign key to rtable for a DataFrame in the catalog.</p>
<p>Specifically this function is a sugar function that will set the foreign
key to right table using set_property function. This function
is typically called on a DataFrame which contains metadata such as
fk_ltable, fk_rtable, ltable, rtable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which the foreign key
rtable property must be set.</li>
<li><strong>foreign_key_rtable</strong> (<em>string</em>) – The attribute that must be set as
foreign key to rtable in the catalog.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>A Boolean value of True is returned if the foreign key to rtable was</dt>
<dd><p class="first last">set successfully.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type
pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>foreign_key_rtable</cite> is not of
type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>fk_rtable</cite> is not in the input
DataFrame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_fk_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_fk_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go"># &#39;rtable_id&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_ltable">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_ltable</code><span class="sig-paren">(</span><em>candset</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_ltable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the ltable for a DataFrame from the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>candset</strong> (<em>DataFrame</em>) – The input table for which the ltable must be
returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A pandas DataFrame that is pointed by ‘ltable’ property of the input
table.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">get_ltable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.set_ltable">
<code class="descclassname">py_entitymatching.</code><code class="descname">set_ltable</code><span class="sig-paren">(</span><em>candset</em>, <em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.set_ltable" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the ltable for a DataFrame in the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>candset</strong> (<em>DataFrame</em>) – The input table for which the ltable must be set.</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The table (typically a pandas DataFrame) that must
be set as ltable for the input DataFrame.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A Boolean value of True is returned, if the update was successful.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_ltable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">get_ltable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go"># True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_rtable">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_rtable</code><span class="sig-paren">(</span><em>candset</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rtable for a DataFrame from the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>candset</strong> (<em>DataFrame</em>) – Input table for which the rtable must be returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A pandas DataFrame that is pointed by ‘rtable’ property of the input
table.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">get_rtable</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go"># True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.get_property" title="py_entitymatching.get_property"><code class="xref py py-meth docutils literal"><span class="pre">get_property()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.set_rtable">
<code class="descclassname">py_entitymatching.</code><code class="descname">set_rtable</code><span class="sig-paren">(</span><em>candset</em>, <em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.set_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rtable for a DataFrame in the catalog.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>candset</strong> (<em>DataFrame</em>) – The input table for which the rtable must be set.</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The table that must be set as rtable for the input
DataFrame.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A Boolean value of True is returned, if the update was successful.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;colA&#39;</span><span class="p">:[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;colB&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">set_rtable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">get_rtable</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go"># True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.set_property" title="py_entitymatching.set_property"><code class="xref py py-meth docutils literal"><span class="pre">set_property()</span></code></a></p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/downsampling"></span><div class="section" id="downsampling">
<h3>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.down_sample">
<code class="descclassname">py_entitymatching.</code><code class="descname">down_sample</code><span class="sig-paren">(</span><em>table_a</em>, <em>table_b</em>, <em>size</em>, <em>y_param</em>, <em>show_progress=True</em>, <em>verbose=False</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.down_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>This function down samples two tables A and B into smaller tables A’ and
B’ respectively.</p>
<p>Specifically, first it randomly selects <cite>size</cite> tuples
from the table B to be table B’. Next, it builds an inverted index I
(token, tuple_id) on table A. For each tuple x ∈ B’, the algorithm
finds a set P of k/2 tuples from I that match x,
and a set Q of k/2 tuples randomly selected from A - P.
The idea is for A’ and B’ to share some matches yet be
as representative of A and B as possible.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>table_a</strong><strong>,</strong><strong>table_b</strong> (<em>DataFrame</em>) – The input tables A and B.</li>
<li><strong>size</strong> (<em>int</em>) – The size that table B should be down sampled to.</li>
<li><strong>y_param</strong> (<em>int</em>) – The parameter to control the down sample size of table A.
Specifically, the down sampled size of table A should be close to
size * y_param.</li>
<li><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether a progress bar
should be displayed (defaults to True).</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be displayed (defaults to False).</li>
<li><strong>seed</strong> (<em>int</em>) – The seed for the pseudo random number generator to select
the tuples from A and B (defaults to None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Down sampled tables A and B as pandas DataFrames.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If any of the input tables (<cite>table_a</cite>, <cite>table_b</cite>) are
empty or not a DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>size</cite> or <cite>y_param</cite> is empty or 0 or not a
valid integer value.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>seed</cite> is not a valid integer
value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_A</span><span class="p">,</span> <span class="n">sample_B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">down_sample</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p># Example with seed = 0. This means the same sample data set will be returned
# each time this function is run.
&gt;&gt;&gt; A = em.read_csv_metadata(‘path_to_csv_dir/table_A.csv’, key=’ID’)
&gt;&gt;&gt; B = em.read_csv_metadata(‘path_to_csv_dir/table_B.csv’, key=’ID’)
&gt;&gt;&gt; sample_A, sample_B = em.down_sample(A, B, 500, 1, seed=0)</p>
</dd></dl>

</div>
<span id="document-user_manual/api/data_exploration"></span><div class="section" id="data-exploration">
<h3>Data Exploration<a class="headerlink" href="#data-exploration" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="py_entitymatching.data_explore_openrefine">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">data_explore_openrefine</code><a class="headerlink" href="#py_entitymatching.data_explore_openrefine" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper function for using OpenRefine. Gives user a GUI to examine and edit
the dataframe passed in using OpenRefine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>df</strong> (<em>Dataframe</em>) – The pandas dataframe to be explored with pandastable.</li>
<li><strong>server</strong> (<em>String</em>) – The address of the OpenRefine server (defaults to
<a class="reference external" href="http://127.0.0.1:3333">http://127.0.0.1:3333</a>).</li>
<li><strong>name</strong> (<em>String</em>) – The name given to the file and project in OpenRefine.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>df</cite> is not of type pandas DataFrame.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">data_explore_openrefine</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Table&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="py_entitymatching.data_explore_pandastable">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">data_explore_pandastable</code><a class="headerlink" href="#py_entitymatching.data_explore_pandastable" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper function for pandastable. Gives user a GUI to examine and edit
the dataframe passed in using pandastable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>df</strong> (<em>Dataframe</em>) – The pandas dataframe to be explored with pandastable.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>df</cite> is not of type pandas DataFrame.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">data_explore_pandastable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/blocking"></span><div class="section" id="blocking">
<h3>Blocking<a class="headerlink" href="#blocking" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="py_entitymatching.AttrEquivalenceBlocker">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">AttrEquivalenceBlocker</code><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks based on the equivalence of attribute values.</p>
<dl class="method">
<dt id="py_entitymatching.AttrEquivalenceBlocker.block_candset">
<code class="descname">block_candset</code><span class="sig-paren">(</span><em>candset</em>, <em>l_block_attr</em>, <em>r_block_attr</em>, <em>allow_missing=False</em>, <em>verbose=False</em>, <em>show_progress=True</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks an input candidate set of tuple pairs based on attribute equivalence.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs
such that the value of attribute l_block_attr of the left tuple in a
tuple pair exactly matches the value of attribute r_block_attr of the
right tuple in the tuple pair.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</li>
<li><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left table.</li>
<li><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right table.</li>
<li><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple pair with missing value in either
blocking attribute will be retained in the
output candidate set.</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</li>
<li><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</li>
<li><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>candset</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_block_attr</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_block_attr</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>verbose</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>n_jobs</cite> is not of type
int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_block_attr</cite> is not in the ltable columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_block_attr</cite> is not in the rtable columns.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Execute blocking using multiple cores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.AttrEquivalenceBlocker.block_tables">
<code class="descname">block_tables</code><span class="sig-paren">(</span><em>ltable</em>, <em>rtable</em>, <em>l_block_attr</em>, <em>r_block_attr</em>, <em>l_output_attrs=None</em>, <em>r_output_attrs=None</em>, <em>l_output_prefix=’ltable_’</em>, <em>r_output_prefix=’rtable_’</em>, <em>allow_missing=False</em>, <em>verbose=False</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks two tables based on attribute equivalence.</p>
<p>Conceptually, this will check <cite>l_block_attr=r_block_attr</cite> for each tuple
pair from the Cartesian product of tables <cite>ltable</cite> and <cite>rtable</cite>. It outputs a
Pandas dataframe object with tuple pairs that satisfy the equality condition.
The dataframe will include attributes ‘_id’, key attribute from
ltable, key attributes from rtable, followed by lists <cite>l_output_attrs</cite> and
<cite>r_output_attrs</cite> if they are specified. Each of these output and key attributes will be
prefixed with given <cite>l_output_prefix</cite> and <cite>r_output_prefix</cite>. If <cite>allow_missing</cite> is set
to <cite>True</cite> then all tuple pairs with missing value in at least one of the tuples will be
included in the output dataframe.
Further, this will update the following metadata in the catalog for the output table:
(1) key, (2) ltable, (3) rtable, (4) fk_ltable, and (5) fk_rtable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</li>
<li><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</li>
<li><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left table.</li>
<li><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right table.</li>
<li><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</li>
<li><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</li>
<li><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</li>
<li><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</li>
<li><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</li>
<li><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rtable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_block_attr</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_block_attr</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_output_attrs</cite> is not of type of
list.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_output_attrs</cite> is not of type of
list.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the values in <cite>l_output_attrs</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the values in <cite>r_output_attrs</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_output_prefix</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_output_prefix</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>verbose</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>allow_missing</cite> is not of type boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>n_jobs</cite> is not of type
int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_block_attr</cite> is not in the ltable columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_block_attr</cite> is not in the rtable columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_out_attrs</cite> are not in the ltable.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_out_attrs</cite> are not in the rtable.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.AttrEquivalenceBlocker.block_tuples">
<code class="descname">block_tuples</code><span class="sig-paren">(</span><em>ltuple</em>, <em>rtuple</em>, <em>l_block_attr</em>, <em>r_block_attr</em>, <em>allow_missing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.AttrEquivalenceBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on attribute equivalence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</li>
<li><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</li>
<li><strong>l_block_attr</strong> (<em>string</em>) – The blocking attribute in left tuple.</li>
<li><strong>r_block_attr</strong> (<em>string</em>) – The blocking attribute in right tuple.</li>
<li><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether a tuple pair
with missing value in at least one of the
blocking attributes should be blocked
(defaults to False). If this flag is set
to True, the pair will be kept if either
ltuple has missing value in l_block_attr
or rtuple has missing value in r_block_attr
or both.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A status indicating if the tuple pair is blocked, i.e., the values
of l_block_attr in ltuple and r_block_attr in rtuple are different
(boolean).</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.OverlapBlocker">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">OverlapBlocker</code><a class="headerlink" href="#py_entitymatching.OverlapBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks  based on the overlap of token sets of attribute values.</p>
<dl class="method">
<dt id="py_entitymatching.OverlapBlocker.block_candset">
<code class="descname">block_candset</code><span class="sig-paren">(</span><em>candset</em>, <em>l_overlap_attr</em>, <em>r_overlap_attr</em>, <em>rem_stop_words=False</em>, <em>q_val=None</em>, <em>word_level=True</em>, <em>overlap_size=1</em>, <em>allow_missing=False</em>, <em>verbose=False</em>, <em>show_progress=True</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.OverlapBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Blocks an input candidate set of tuple pairs based on the overlap</dt>
<dd>of token sets of attribute values.</dd>
</dl>
<p>Finds tuple pairs from an input candidate set of tuple pairs such that
the overlap between (a) the set of tokens obtained by tokenizing the
value of attribute l_overlap_attr of the left tuple in a tuple pair,
and (b) the set of tokens obtained by tokenizing the value of
attribute r_overlap_attr of the right tuple in the tuple pair,
is above a certain threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</li>
<li><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left table.</li>
<li><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right table.</li>
<li><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed
from the token sets of the overlap
attribute values (defaults to False).</li>
<li><strong>q_val</strong> (<em>int</em>) – The value of q to use if the overlap attributes values
are to be tokenized as qgrams (defaults to None).</li>
<li><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words
(i.e, using whitespace as delimiter)
(defaults to True).</li>
<li><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must overlap
(defaults to 1).</li>
<li><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple pair with missing value in either
blocking attribute will be retained in the
output candidate set.</li>
<li><strong>verbose</strong> (<em>boolean</em>) – <p>A flag to indicate whether the debug information</p>
<p>should be logged (defaults to False).</p>
</li>
<li><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</li>
<li><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>candset</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_overlap_attr</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_overlap_attr</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>q_val</cite> is not of type int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>word_level</cite> is not of type boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>overlap_size</cite> is not of type int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>verbose</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>allow_missing</cite> is not of type boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>show_progress</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>n_jobs</cite> is not of type
int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_overlap_attr</cite> is not in the ltable
columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_block_attr</cite> is not in the rtable columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code> – If <cite>q_val</cite> is set to a valid value and
<cite>word_level</cite> is set to True.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code> – If <cite>q_val</cite> is set to None and
<cite>word_level</cite> is set to False.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D1</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Include all possible tuple pairs with missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Execute blocking using multiple cores</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># Use q-gram tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">q_val</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.OverlapBlocker.block_tables">
<code class="descname">block_tables</code><span class="sig-paren">(</span><em>ltable</em>, <em>rtable</em>, <em>l_overlap_attr</em>, <em>r_overlap_attr</em>, <em>rem_stop_words=False</em>, <em>q_val=None</em>, <em>word_level=True</em>, <em>overlap_size=1</em>, <em>l_output_attrs=None</em>, <em>r_output_attrs=None</em>, <em>l_output_prefix=’ltable_’</em>, <em>r_output_prefix=’rtable_’</em>, <em>allow_missing=False</em>, <em>verbose=False</em>, <em>show_progress=True</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.OverlapBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Blocks two tables based on the overlap of token sets of attribute</dt>
<dd>values.</dd>
</dl>
<p>Finds tuple pairs from left and right tables such that the overlap
between (a) the set of tokens obtained by tokenizing the value of
attribute l_overlap_attr of a tuple from the left table, and (b) the
set of tokens obtained by tokenizing the value of attribute
r_overlap_attr of a tuple from the right table, is above a certain
threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</li>
<li><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</li>
<li><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left table.</li>
<li><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right table.</li>
<li><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed from the token sets of the
overlap attribute values (defaults to False).</li>
<li><strong>q_val</strong> (<em>int</em>) – The value of q to use if the overlap attributes
values are to be tokenized as qgrams (defaults to None).</li>
<li><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words (i.e, using whitespace
as delimiter) (defaults to True).</li>
<li><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must
overlap (defaults to 1).</li>
<li><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the output candidate set (defaults
to None).</li>
<li><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the output candidate set  (defaults
to None).</li>
<li><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</li>
<li><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</li>
<li><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether tuple pairs
with missing value in at least one of the
blocking attributes should be included in
the output candidate set (defaults to
False). If this flag is set to True, a
tuple in ltable with missing value in the
blocking attribute will be matched with
every tuple in rtable and vice versa.</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</li>
<li><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</li>
<li><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine). Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rtable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_overlap_attr</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_overlap_attr</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_output_attrs</cite> is not of type of
list.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_output_attrs</cite> is not of type of
list.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the values in <cite>l_output_attrs</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the values in <cite>r_output_attrs</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_output_prefix</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_output_prefix</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>q_val</cite> is not of type int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>word_level</cite> is not of type boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>overlap_size</cite> is not of type int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>verbose</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>allow_missing</cite> is not of type boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>show_progress</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>n_jobs</cite> is not of type
int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_overlap_attr</cite> is not in the ltable
columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_block_attr</cite> is not in the rtable columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_output_attrs</cite> are not in the ltable.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_output_attrs</cite> are not in the rtable.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code> – If <cite>q_val</cite> is set to a valid value and
<cite>word_level</cite> is set to True.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code> – If <cite>q_val</cite> is set to None and
<cite>word_level</cite> is set to False.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="go"># Use word-level tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go"># Use q-gram tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C2</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">word_level</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">q_val</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go"># Include all possible missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Use all the cores in the machine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.OverlapBlocker.block_tuples">
<code class="descname">block_tuples</code><span class="sig-paren">(</span><em>ltuple</em>, <em>rtuple</em>, <em>l_overlap_attr</em>, <em>r_overlap_attr</em>, <em>rem_stop_words=False</em>, <em>q_val=None</em>, <em>word_level=True</em>, <em>overlap_size=1</em>, <em>allow_missing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.OverlapBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Blocks a tuple pair based on the overlap of token sets of attribute</dt>
<dd>values.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</li>
<li><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</li>
<li><strong>l_overlap_attr</strong> (<em>string</em>) – The overlap attribute in left tuple.</li>
<li><strong>r_overlap_attr</strong> (<em>string</em>) – The overlap attribute in right tuple.</li>
<li><strong>rem_stop_words</strong> (<em>boolean</em>) – A flag to indicate whether stop words
(e.g., a, an, the) should be removed
from the token sets of the overlap
attribute values (defaults to False).</li>
<li><strong>q_val</strong> (<em>int</em>) – A value of q to use if the overlap attributes values
are to be tokenized as qgrams (defaults to None).</li>
<li><strong>word_level</strong> (<em>boolean</em>) – A flag to indicate whether the overlap
attributes should be tokenized as words
(i.e, using whitespace as delimiter)
(defaults to True).</li>
<li><strong>overlap_size</strong> (<em>int</em>) – The minimum number of tokens that must overlap
(defaults to 1).</li>
<li><strong>allow_missing</strong> (<em>boolean</em>) – A flag to indicate whether a tuple pair
with missing value in at least one of the
blocking attributes should be blocked
(defaults to False). If this flag is set
to True, the pair will be kept if either
ltuple has missing value in l_block_attr
or rtuple has missing value in r_block_attr
or both.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A status indicating if the tuple pair is blocked (boolean).</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.RuleBasedBlocker">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">RuleBasedBlocker</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks  based on a sequence of blocking rules supplied by the user.</p>
<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.add_rule">
<code class="descname">add_rule</code><span class="sig-paren">(</span><em>conjunct_list</em>, <em>feature_table=None</em>, <em>rule_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.add_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a rule to the rule-based blocker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>conjunct_list</strong> (<em>list</em>) – A list of conjuncts specifying the rule.</li>
<li><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing all the
features that are being referenced by
the rule (defaults to None). If the
feature_table is not supplied here,
then it must have been specified
during the creation of the rule-based
blocker or using set_feature_table
function. Otherwise an AssertionError
will be raised and the rule will not
be added to the rule-based blocker.</li>
<li><strong>rule_name</strong> (<em>string</em>) – A string specifying the name of the rule to
be added (defaults to None). If the
rule_name is not specified then a name will
be automatically chosen. If there is already
a rule with the specified rule_name, then
an AssertionError will be raised and the
rule will not be added to the rule-based
blocker.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The name of the rule added (string).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rule_name</cite> already exists.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>feature_table</cite> is not a valid value
parameter.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.block_candset">
<code class="descname">block_candset</code><span class="sig-paren">(</span><em>candset</em>, <em>verbose=False</em>, <em>show_progress=True</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks an input candidate set of tuple pairs based on a sequence of
blocking rules supplied by the user.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs that
survive the sequence of blocking rules. A tuple pair survives the
sequence of blocking rules if none of the rules in the sequence returns
True for that pair. If any of the rules returns True, then the pair is
blocked (dropped).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information  should be logged (defaults to False).</li>
<li><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</li>
<li><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>candset</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>verbose</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>n_jobs</cite> is not of type
int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>show_progress</cite> is not of type boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_block_attr</cite> is not in the ltable columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_block_attr</cite> is not in the rtable columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If there are no rules to apply.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># C is the candidate set.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.block_tables">
<code class="descname">block_tables</code><span class="sig-paren">(</span><em>ltable</em>, <em>rtable</em>, <em>l_output_attrs=None</em>, <em>r_output_attrs=None</em>, <em>l_output_prefix=’ltable_’</em>, <em>r_output_prefix=’rtable_’</em>, <em>verbose=False</em>, <em>show_progress=True</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks two tables based on the sequence of rules supplied by the user.</p>
<p>Finds tuple pairs from left and right tables that survive the sequence
of blocking rules. A tuple pair survives the sequence of blocking rules
if none of the rules in the sequence returns True for that pair. If any
of the rules returns True, then the pair is blocked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</li>
<li><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</li>
<li><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</li>
<li><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</li>
<li><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</li>
<li><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information  should be logged (defaults to False).</li>
<li><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</li>
<li><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A candidate set of tuple pairs that survived the sequence of
blocking rules (DataFrame).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rtable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_output_attrs</cite> is not of type of
list.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_output_attrs</cite> is not of type of
list.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the values in <cite>l_output_attrs</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the values in <cite>r_output_attrs</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the input <cite>l_output_prefix</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the input <cite>r_output_prefix</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>verbose</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>show_progress</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>n_jobs</cite> is not of type
int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_out_attrs</cite> are not in the ltable.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_out_attrs</cite> are not in the rtable.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If there are no rules to apply.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.block_tuples">
<code class="descname">block_tuples</code><span class="sig-paren">(</span><em>ltuple</em>, <em>rtuple</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on a sequence of blocking rules supplied
by the user.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltuple</strong> (<em>Series</em>) – The input left tuple.</li>
<li><strong>rtuple</strong> (<em>Series</em>) – The input right tuple.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A status indicating if the tuple pair is blocked by applying the
sequence of blocking rules (boolean).</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.delete_rule">
<code class="descname">delete_rule</code><span class="sig-paren">(</span><em>rule_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.delete_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a rule from the rule-based blocker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be deleted.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.get_rule">
<code class="descname">get_rule</code><span class="sig-paren">(</span><em>rule_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.get_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the function corresponding to a rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rule_name</strong> (<em>string</em>) – Name of the rule.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A function object corresponding to the specified rule.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">get_rule</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.get_rule_names">
<code class="descname">get_rule_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.get_rule_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all the rules in the rule-based blocker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of names of all the rules in the rule-based blocker (list).</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.set_feature_table">
<code class="descname">set_feature_table</code><span class="sig-paren">(</span><em>feature_table</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.set_feature_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets feature table for the rule-based blocker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing features.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">set_feature_table</span><span class="p">(</span><span class="n">block_f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RuleBasedBlocker.view_rule">
<code class="descname">view_rule</code><span class="sig-paren">(</span><em>rule_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RuleBasedBlocker.view_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the source code of the function corresponding to a rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be viewed.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">,</span> <span class="n">rule_name</span><span class="o">=</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.BlackBoxBlocker">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">BlackBoxBlocker</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks based on a black box function specified by the user.</p>
<dl class="method">
<dt id="py_entitymatching.BlackBoxBlocker.block_candset">
<code class="descname">block_candset</code><span class="sig-paren">(</span><em>candset</em>, <em>verbose=True</em>, <em>show_progress=True</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.block_candset" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks an input candidate set of tuple pairs based on a black box
blocking function specified by the user.</p>
<p>Finds tuple pairs from an input candidate set of tuple pairs that
survive the black box function. A tuple pair survives the black box
blocking function if the function returns False for that pair,
otherwise the tuple pair is dropped.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set of tuple pairs.</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether logging should be done
(defaults to False).</li>
<li><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</li>
<li><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus is the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>candset</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>verbose</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>n_jobs</cite> is not of type
int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>show_progress</cite> is not of type boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_block_attr</cite> is not in the ltable columns.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_block_attr</cite> is not in the rtable columns.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="c1"># C is an output from block_tables</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.BlackBoxBlocker.block_tables">
<code class="descname">block_tables</code><span class="sig-paren">(</span><em>ltable</em>, <em>rtable</em>, <em>l_output_attrs=None</em>, <em>r_output_attrs=None</em>, <em>l_output_prefix=’ltable_’</em>, <em>r_output_prefix=’rtable_’</em>, <em>verbose=False</em>, <em>show_progress=True</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.block_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks two tables based on a black box blocking function specified
by the user.</p>
<p>Finds tuple pairs from left and right tables that survive the black
box function. A tuple pair survives the black box blocking function if
the function returns False for that pair, otherwise the tuple pair is
dropped.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltable</strong> (<em>DataFrame</em>) – The left input table.</li>
<li><strong>rtable</strong> (<em>DataFrame</em>) – The right input table.</li>
<li><strong>l_output_attrs</strong> (<em>list</em>) – A list of attribute names from the left
table to be included in the
output candidate set (defaults to None).</li>
<li><strong>r_output_attrs</strong> (<em>list</em>) – A list of attribute names from the right
table to be included in the
output candidate set (defaults to None).</li>
<li><strong>l_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the left table in the output
candidate set (defaults to ‘ltable_’).</li>
<li><strong>r_output_prefix</strong> (<em>string</em>) – The prefix to be used for the attribute names
coming from the right table in the output
candidate set (defaults to ‘rtable_’).</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug
information should be logged (defaults to False).</li>
<li><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether progress should
be displayed to the user (defaults to True).</li>
<li><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A candidate set of tuple pairs that survived blocking (DataFrame).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rtable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_output_attrs</cite> is not of type of
list.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_output_attrs</cite> is not of type of
list.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If values in <cite>l_output_attrs</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If values in <cite>r_output_attrs</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_output_prefix</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_output_prefix</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>verbose</cite> is not of type
boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>show_progress</cite> is not of type boolean.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>n_jobs</cite> is not of type
int.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_out_attrs</cite> are not in the ltable.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_out_attrs</cite> are not in the rtable.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.BlackBoxBlocker.block_tuples">
<code class="descname">block_tuples</code><span class="sig-paren">(</span><em>ltuple</em>, <em>rtuple</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.block_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Blocks a tuple pair based on a black box blocking function specified
by the user.</p>
<p>Takes a tuple pair as input, applies the black box blocking function to
it, and returns True (if the intention is to drop the pair) or False
(if the intention is to keep the tuple pair).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltuple</strong> (<em>Series</em>) – input left tuple.</li>
<li><strong>rtuple</strong> (<em>Series</em>) – input right tuple.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A status indicating if the tuple pair should be dropped or kept,
based on the black box blocking function (boolean).</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="go">    # assume that there is a &#39;name&#39; attribute in the input tables</span>
<span class="go">    # and each value in it has two words</span>
<span class="go">    l_last_name = ltuple[&#39;name&#39;].split()[1]</span>
<span class="go">    r_last_name = rtuple[&#39;name&#39;].split()[1]</span>
<span class="go">    if l_last_name != r_last_name:</span>
<span class="go">        return True</span>
<span class="go">    else:</span>
<span class="go">        return False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># A, B are input tables.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.BlackBoxBlocker.set_black_box_function">
<code class="descname">set_black_box_function</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.BlackBoxBlocker.set_black_box_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets black box function to be used for blocking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>function</strong> (<em>function</em>) – the black box function to be used for blocking .</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<span id="document-user_manual/api/debugging_blocker_output"></span><div class="section" id="debugging-blocker-output">
<h3>Debugging Blocker Output<a class="headerlink" href="#debugging-blocker-output" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.debug_blocker">
<code class="descclassname">py_entitymatching.</code><code class="descname">debug_blocker</code><span class="sig-paren">(</span><em>candidate_set</em>, <em>ltable</em>, <em>rtable</em>, <em>output_size=200</em>, <em>attr_corres=None</em>, <em>verbose=True</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.debug_blocker" title="Permalink to this definition">¶</a></dt>
<dd><p>This function debugs the blocker output and reports a list of potential
matches that are discarded by a blocker (or a blocker sequence).
Specifically,  this function takes in the two input tables for
matching and the candidate set returned by a blocker (or a blocker
sequence), and produces a list of tuple pairs which are rejected by the
blocker but with high potential of being true matches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>candidate_set</strong> (<em>DataFrame</em>) – The candidate set generated by
applying the blocker on the ltable and rtable.</li>
<li><strong>ltable</strong><strong>,</strong><strong>rtable</strong> (<em>DataFrame</em>) – The input DataFrames that are used to
generate the blocker output.</li>
<li><strong>output_size</strong> (<em>int</em>) – The number of tuple pairs that will be
returned (defaults to 200).</li>
<li><strong>attr_corres</strong> (<em>list</em>) – A list of attribute correspondence tuples.
When ltable and rtable have different schemas, or the same
schema but different words describing the attributes, the
user needs to manually specify the attribute correspondence.
Each element in this list should be a tuple of strings
which are the corresponding attributes in ltable and rtable.
The default value is None, and if the user doesn’t specify
this list, a built-in function for finding the
attribute correspondence list will be called. But we highly
recommend the users manually specify the attribute
correspondences, unless the schemas of ltable and rtable are
identical (defaults to None).</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</li>
<li><strong>n_jobs</strong> (<em>int</em>) – The number of parallel jobs to be used for computation
(defaults to 1). If -1 all CPUs are used. If 0 or 1,
no parallel computation is used at all, which is useful for
debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are
used (where n_cpus are the total number of CPUs in the
machine).Thus, for n_jobs = -2, all CPUs but one are used.
If (n_cpus + 1 + n_jobs) is less than 1, then no parallel
computation is used (i.e., equivalent to the default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A pandas DataFrame with ‘output_size’ number of rows. Each row in the
DataFrame is a tuple pair which has potential of being a true
match, but is rejected by the blocker (meaning that the tuple
pair is in the Cartesian product of ltable and rtable subtracted
by the candidate set). The fields in the returned DataFrame are
from ltable and rtable, which are useful for determining similar
tuple pairs.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite>, <cite>rtable</cite> or <cite>candset</cite> is not of type
pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite> or <cite>rtable</cite> is empty (size of 0).</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the output <cite>size</cite> parameter is less than or equal
to 0.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the attribute correspondence (<cite>attr_corres</cite>) list is
not in the correct format (a list of tuples).</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the attribute correspondence (<cite>attr_corres</cite>)
cannot be built correctly.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corres</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span><span class="s1">&#39;ssn&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;ename&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">),(</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">attr_corres</span><span class="o">=</span><span class="n">corres</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/combining_blocker_outputs"></span><div class="section" id="combining-blocker-outputs">
<h3>Combining Blocker Outputs<a class="headerlink" href="#combining-blocker-outputs" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.combine_blocker_outputs_via_union">
<code class="descclassname">py_entitymatching.</code><code class="descname">combine_blocker_outputs_via_union</code><span class="sig-paren">(</span><em>blocker_output_list</em>, <em>l_prefix=’ltable_’</em>, <em>r_prefix=’rtable_’</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.combine_blocker_outputs_via_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines multiple blocker outputs by doing a union of their tuple pair
ids (foreign key ltable, foreign key rtable).</p>
<p>Specifically, this function takes in a list of DataFrames (candidate
sets, typically the
output from blockers) and returns a consolidated DataFrame. The output
DataFrame contains the union of tuple pair ids (foreign key ltable,
foreign key rtable) and other attributes from the input list of DataFrames.</p>
<p>This function makes some assumptions about the input DataFrames. First,
each DataFrame is expected to contain the following metadata in the
catalog: key, fk_ltable, fk_rtable, ltable, and rtable. Second,
all the DataFrames must be a result of blocking from the same underlying
tables. Concretely the ltable and rtable properties must refer to the
same DataFrame across all the input tables. Third, all the input
DataFrames must have the same fk_ltable and fk_rtable properties.
Finally, in each input DataFrame, for the attributes included from the
ltable or rtable, the attribute names must be prefixed with the given
l_prefix and r_prefix in the function.</p>
<p>The input DataFrames may contain different attribute lists and it demands
the question of how to combine them. Currently py_entitymatching takes an union
of attribute names that has prefix l_prefix or r_prefix across
input tables. After taking the union, for each tuple id pair included
in output, the attribute values (for union-ed attribute names) are
probed from ltable/rtable and included in the output.</p>
<p>A subtle point to note here is,  if an input DataFrame has a column
added by user (say label for some reason), then that column will not
be present in the output. The reason is, the same column may not be
present in other candidate sets so it is not clear about how to
combine them. One possibility is to include label in output for all
tuple id pairs, but set as NaN for the values not present. Currently
py_entitymatching does not include such columns and addressing it will be part
of future work.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>blocker_output_list</strong> (<em>list of DataFrames</em>) – The list of DataFrames that
should be combined.</li>
<li><strong>l_prefix</strong> (<em>string</em>) – The prefix given to the attributes from the ltable.</li>
<li><strong>r_prefix</strong> (<em>string</em>) – The prefix given to the attributes from the rtable.</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether more detailed information
about the execution steps should be printed out (default value is
False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new DataFrame with the combined tuple pairs and other attributes from
all the blocker lists.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_prefix</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_prefix</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the length of the input DataFrame list is 0.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>blocker_output_list</cite> is not a list of
DataFrames.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the ltables are different across the input list of
DataFrames.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the rtables are different across the input list of
DataFrames.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>fk_ltable</cite> values are different across the
input list of DataFrames.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>fk_rtable</cite> values are different across the
input list of DataFrames.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">combine_blocker_outputs_via_union</span><span class="p">([</span><span class="n">C</span><span class="p">,</span> <span class="n">E</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/sampling"></span><div class="section" id="sampling">
<h3>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.sample_table">
<code class="descclassname">py_entitymatching.</code><code class="descname">sample_table</code><span class="sig-paren">(</span><em>table</em>, <em>sample_size</em>, <em>replace=False</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.sample_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples a candidate set of tuple pairs (for labeling purposes).</p>
<p>This function samples a DataFrame, typically used for labeling
purposes. This function expects the input DataFrame containing the
metadata of a candidate set (such as key, fk_ltable, fk_rtable, ltable,
rtable). Specifically, this function creates a copy of the input
DataFrame, samples the data using uniform random sampling (uses ‘random’
function from numpy to sample) and returns the sampled DataFrame.
Further, also copies the properties from the input DataFrame to the output
DataFrame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>table</strong> (<em>DataFrame</em>) – The input DataFrame to be sampled.
Specifically,
a DataFrame containing the metadata of a candidate set (such as
key, fk_ltable, fk_rtable, ltable, rtable) in the catalog.</li>
<li><strong>sample_size</strong> (<em>int</em>) – The number of samples to be picked from the input
DataFrame.</li>
<li><strong>replace</strong> (<em>boolean</em>) – A flag to indicate whether sampling should be
done with replacement or not (defaults to False).</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether more detailed information
about the execution steps should be printed out (defaults to False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>A new DataFrame with ‘sample_size’ number of rows.</p>
<p>Further,
this function sets the output DataFrame’s properties same as input
DataFrame.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>table</cite> is not of type pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the size of <cite>table</cite> is 0.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>sample_size</cite> is greater than the input
DataFrame size.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">sample_table</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="mi">450</span><span class="p">)</span> <span class="c1"># C is the candidate set to be sampled from.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As mentioned in the above description, the output DataFrame is
updated (in the catalog) with the properties from the input
DataFrame. A subtle point to note here is, when the replace flag is
set to True, then the output  DataFrame can contain duplicate keys.
In that case, this function  will not set the key and it is up to
the user to fix it after the function returns.</p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/labeling"></span><div class="section" id="labeling">
<h3>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.label_table">
<code class="descclassname">py_entitymatching.</code><code class="descname">label_table</code><span class="sig-paren">(</span><em>table</em>, <em>label_column_name</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.label_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Label a pandas DataFrame (for supervised learning purposes).</p>
<p>This functions labels a DataFrame, typically used for supervised learning
purposes. This function expects the input DataFrame containing the metadata
of a candidate set (such as key, fk_ltable, fk_rtable, ltable, rtable).
This function creates a copy of the input DataFrame, adds label column
at the end of the DataFrame, fills the column values with 0, invokes a
GUI for the user to enter labels (0/1, 0: non-match, 1: match) and finally
returns the labeled DataFrame. Further, this function also copies the
properties from the input DataFrame to the output DataFrame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>table</strong> (<em>DataFrame</em>) – The input DataFrame to be labeled.
Specifically,
a DataFrame containing the metadata of a candidate set (such as
key, fk_ltable, fk_rtable, ltable, rtable) in the catalog.</li>
<li><strong>label_column_name</strong> (<em>string</em>) – The column name to be given for the labels
entered by the user.</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether more detailed information
about the execution steps should be printed out (default value is
False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new DataFrame with the labels entered by the user. Further,
this function sets the output DataFrame’s properties same as input
DataFrame.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>table</cite> is not of type pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>label_column_name</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>label_column_name</cite> is already present in the
input table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">label_table</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">label_column_name</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># S is the (sampled) table that has to be labeled.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.new_label_table">
<code class="descclassname">py_entitymatching.</code><code class="descname">new_label_table</code><span class="sig-paren">(</span><em>df</em>, <em>label_column_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.new_label_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to be invoked to launch the Labeler application.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>df</strong> (<em>Dataframe</em>) – A Dataframe containing the tuple pairs that are possible matches</li>
<li><strong>label_column_name</strong> (<em>str</em>) – Name of column to be used to save tuple pair labels.
This column will be created if it doesn’t already exist.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The updated Dataframe with the label column, comments, and tags</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>table</cite> is not of type pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>label_column_name</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code> – If python version is less than 3.5</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<span id="document-user_manual/api/handling_features"></span><div class="section" id="handling-features">
<h3>Handling Features<a class="headerlink" href="#handling-features" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/creating_the_features_automatically"></span><div class="section" id="creating-the-features-automatically">
<h4>Creating the Features Automatically<a class="headerlink" href="#creating-the-features-automatically" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="py_entitymatching.get_features_for_blocking">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_features_for_blocking</code><span class="sig-paren">(</span><em>ltable</em>, <em>rtable</em>, <em>validate_inferred_attr_types=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_features_for_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>This function automatically generates features that can be used for
blocking purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltable</strong><strong>,</strong><strong>rtable</strong> (<em>DataFrame</em>) – The pandas DataFrames for which the
features are to be generated.</li>
<li><strong>validate_inferred_attr_types</strong> (<em>boolean</em>) – A flag to indicate whether to
show the user the inferred attribute types and the features
chosen for those types.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>A pandas DataFrame containing automatically generated features.</p>
<p>Specifically, the DataFrame contains the following attributes:
‘feature_name’, ‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, ‘simfunction’,
‘function’, ‘function_source’, and ‘is_auto_generated’.</p>
<p>Further, this function also sets the following global variables:
_block_t, _block_s, _atypes1, _atypes2, and _block_c.</p>
<p>The variable _block_t contains the tokenizers used and  _block_s
contains the similarity functions used for creating features.</p>
<p>The variables _atypes1, and  _atypes2 contain the attribute types for
ltable and rtable respectively. The variable _block_c contains the
attribute correspondences between the two input tables.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rtable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>validate_inferred_attr_types</cite> is not of type
pandas DataFrame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the output DataFrame, two
attributes demand some explanation: (1) function, and (2)
is_auto_generated. The function, points to the actual Python function
that implements the feature. Specifically, the function takes in two
tuples (one from each input table) and returns a numeric value. The
attribute is_auto_generated contains either True or False. The flag
is True only if the feature is automatically generated by py_entitymatching.
This is important because this flag is used to make some assumptions
about the semantics of the similarity function used and use that
information for scaling purposes.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="index.html#py_entitymatching.get_attr_corres" title="py_entitymatching.get_attr_corres"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_attr_corres()</span></code></a>, <a class="reference internal" href="index.html#py_entitymatching.get_attr_types" title="py_entitymatching.get_attr_types"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_attr_types()</span></code></a>,
<a class="reference internal" href="index.html#py_entitymatching.get_sim_funs_for_blocking" title="py_entitymatching.get_sim_funs_for_blocking"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_sim_funs_for_blocking()</span></code></a>
<a class="reference internal" href="index.html#py_entitymatching.get_tokenizers_for_blocking" title="py_entitymatching.get_tokenizers_for_blocking"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_tokenizers_for_blocking()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_features_for_matching">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_features_for_matching</code><span class="sig-paren">(</span><em>ltable</em>, <em>rtable</em>, <em>validate_inferred_attr_types=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_features_for_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>This function automatically generates features that can be used for
matching purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltable</strong><strong>,</strong><strong>rtable</strong> (<em>DataFrame</em>) – The pandas DataFrames for which the
features are to be generated.</li>
<li><strong>validate_inferred_attr_types</strong> (<em>boolean</em>) – A flag to indicate whether to
show the user the inferred attribute types and the features
chosen for those types.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>A pandas DataFrame containing automatically generated features.</p>
<p>Specifically, the DataFrame contains the following attributes:
‘feature_name’, ‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, ‘simfunction’,
‘function’, ‘function_source’, and ‘is_auto_generated’.</p>
<p>Further, this function also sets the following global variables:
_match_t, _match_s, _atypes1, _atypes2, and _match_c.</p>
<p>The variable _match_t contains the tokenizers used and  _match_s
contains the similarity functions used for creating features.</p>
<p>The variables _atypes1, and  _atypes2 contain the attribute types for
ltable and rtable respectively. The variable _match_c contains the
attribute correspondences between the two input tables.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rtable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>validate_inferred_attr_types</cite> is not of type
pandas DataFrame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the output DataFrame, two
attributes demand some explanation: (1) function, and (2)
is_auto_generated. The function, points to the actual Python function
that implements the feature. Specifically, the function takes in two
tuples (one from each input table) and returns a numeric value. The
attribute is_auto_generated contains either True or False. The flag
is True only if the feature is automatically generated by py_entitymatching.
This is important because this flag is used to make some assumptions
about the semantics of the similarity function used and use that
information for scaling purposes.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="index.html#py_entitymatching.get_attr_corres" title="py_entitymatching.get_attr_corres"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_attr_corres()</span></code></a>, <a class="reference internal" href="index.html#py_entitymatching.get_attr_types" title="py_entitymatching.get_attr_types"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_attr_types()</span></code></a>,
<a class="reference internal" href="index.html#py_entitymatching.get_sim_funs_for_matching" title="py_entitymatching.get_sim_funs_for_matching"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code></a>
<a class="reference internal" href="index.html#py_entitymatching.get_tokenizers_for_matching" title="py_entitymatching.get_tokenizers_for_matching"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_tokenizers_for_matching()</span></code></a></p>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/creating_the_features_manually"></span><div class="section" id="creating-the-features-manually">
<h4>Creating the Features Manually<a class="headerlink" href="#creating-the-features-manually" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="py_entitymatching.get_features">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_features</code><span class="sig-paren">(</span><em>ltable</em>, <em>rtable</em>, <em>l_attr_types</em>, <em>r_attr_types</em>, <em>attr_corres</em>, <em>tok_funcs</em>, <em>sim_funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_features" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will automatically generate a set of features based on the
attributes of the input tables.</p>
<p>Specifically, this function will go through the attribute
correspondences between the input tables. For each correspondence ,
it examines the types of the involved attributes, then apply the
appropriate tokenizers and sim functions to generate all appropriate
features for this correspondence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ltable</strong><strong>,</strong><strong>rtable</strong> (<em>DataFrame</em>) – The pandas DataFrames for which the
features must be generated.</li>
<li><strong>l_attr_types</strong><strong>,</strong><strong>r_attr_types</strong> (<em>dictionary</em>) – The attribute types for the
input DataFrames. Typically this is generated using the
function ‘get_attr_types’.</li>
<li><strong>attr_corres</strong> (<em>dictionary</em>) – The attribute correspondences between the
input DataFrames.</li>
<li><strong>tok_funcs</strong> (<em>dictionary</em>) – A Python dictionary containing tokenizer
functions.</li>
<li><strong>sim_funcs</strong> (<em>dictionary</em>) – A Python dictionary containing similarity
functions.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A pandas DataFrame containing automatically generated features.
Specifically, the DataFrame contains the following attributes:
‘feature_name’, ‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, ‘simfunction’,
‘function’, ‘function_source’, ‘is_auto_generated’.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rtable</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>l_attr_types</cite> is not of type
python dictionary.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>r_attr_types</cite> is not of type
python dictionary.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>attr_corres</cite> is not of type
python dictionary.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>sim_funcs</cite> is not of type
python dictionary.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>tok_funcs</cite> is not of type
python dictionary.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>ltable</cite> and <cite>rtable</cite> order is same as mentioned
in the <cite>l_attr_types</cite>/<cite>r_attr_types</cite> and <cite>attr_corres</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes1 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes2 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atype2</span><span class="p">,</span> <span class="n">match_c</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#py_entitymatching.get_attr_corres" title="py_entitymatching.get_attr_corres"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_attr_corres()</span></code></a>, <a class="reference internal" href="#py_entitymatching.get_attr_types" title="py_entitymatching.get_attr_types"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_attr_types()</span></code></a>,
<a class="reference internal" href="#py_entitymatching.get_sim_funs_for_blocking" title="py_entitymatching.get_sim_funs_for_blocking"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_sim_funs_for_blocking()</span></code></a>,
<a class="reference internal" href="#py_entitymatching.get_tokenizers_for_blocking" title="py_entitymatching.get_tokenizers_for_blocking"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_tokenizers_for_blocking()</span></code></a>,
<a class="reference internal" href="#py_entitymatching.get_sim_funs_for_matching" title="py_entitymatching.get_sim_funs_for_matching"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code></a>,
<a class="reference internal" href="#py_entitymatching.get_tokenizers_for_matching" title="py_entitymatching.get_tokenizers_for_matching"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_tokenizers_for_matching()</span></code></a></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the output DataFrame, two
attributes demand some explanation: (1)function, and (2)
is_auto_generated. The function, points to the actual python function
that implements feature. Specifically, the function takes in two
tuples (one from each input table) and returns a numeric value. The
attribute is_auto_generated contains either True or False. The flag
is True only if the feature is automatically generated by py_entitymatching.
This is important because this flag is used to make some assumptions
about the semantics of the similarity function used and use that
information for scaling purposes.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_attr_corres">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_attr_corres</code><span class="sig-paren">(</span><em>ltable</em>, <em>rtable</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_attr_corres" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the attribute correspondences between the attributes
of ltable and rtable.</p>
<p>The user may need to get the correspondences so
that he/she can generate features based those correspondences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ltable</strong><strong>,</strong><strong>rtable</strong> (<em>DataFrame</em>) – Input DataFrames for which
the attribute correspondences must be obtained.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>A Python dictionary is returned containing the attribute
correspondences.</p>
<p>Specifically, this returns a dictionary with the following key-value
pairs:</p>
<p>corres: points to the list correspondences as tuples. Each
correspondence is a tuple with two attributes: one from ltable
and the other from rtable.</p>
<p>ltable: points to ltable.</p>
<p>rtable: points to rtable.</p>
<p>Currently, ‘corres’ contains only pairs of attributes with exact
names in ltable and rtable.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>ltable</cite> is not of type
pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rtable</cite> is not of type
pandas DataFrame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_attr_types">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_attr_types</code><span class="sig-paren">(</span><em>data_frame</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_attr_types" title="Permalink to this definition">¶</a></dt>
<dd><p>This function gets the attribute types for a DataFrame.</p>
<p>Specifically this function gets the attribute types based on the
statistics of the attributes. These attribute types can be str_eq_1w,
str_bt_1w_5w, str_bt_5w_10w, str_gt_10w, boolean or numeric.</p>
<p>The types roughly capture whether the attribute is of type string,
boolean or numeric. Further, with in the string type the subtypes are
capture the average number of tokens in the column values. For example,
str_bt_1w_5w means the average number of tokens in that column is
greater than one word but less than 5 words.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data_frame</strong> (<em>DataFrame</em>) – The input DataFrame for which types of
attributes must be determined.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A Python dictionary is returned containing the attribute types.<p>Specifically, in the dictionary key is an attribute name, value
is the type of that attribute.</p>
<p>Further, the dictionary will have a  key _table, and the value of
that should be a pointer to the input DataFrame.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type
pandas DataFrame.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_sim_funs_for_blocking">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_sim_funs_for_blocking</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_sim_funs_for_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the similarity functions that can be used for
blocking purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Python dictionary containing the similarity functions.<p>Specifically, the key is the similarity function name and the value
is the actual similary function.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_sim_funs_for_matching">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_sim_funs_for_matching</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_sim_funs_for_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the similarity functions that can be used for
matching purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Python dictionary containing the similarity functions.<p>Specifically, the key is the similarity function name and the value
is the actual similarity function.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_tokenizers_for_blocking">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_tokenizers_for_blocking</code><span class="sig-paren">(</span><em>q=[2, 3], dlm_char=[‘ ‘]</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_tokenizers_for_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the single argument tokenizers that can be used for
blocking purposes (typically in rule-based blocking).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>q</strong> (<em>list</em>) – The list of integers (i.e q value) for which the q-gram
tokenizer must be generated (defaults to [2, 3]).</li>
<li><strong>dlm_char</strong> (<em>list</em>) – The list of characters (i.e delimiter character) for
which the delimiter tokenizer must be generated (defaults to [` ‘]).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Python dictionary with tokenizer name as the key and tokenizer
function as the value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If both <cite>q</cite> and <cite>dlm_char</cite> are set to None.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dlm_char</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dlm_char</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_tokenizers_for_matching">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_tokenizers_for_matching</code><span class="sig-paren">(</span><em>q=[2, 3], dlm_char=[‘ ‘]</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_tokenizers_for_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the single argument tokenizers that can be used for
matching purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>q</strong> (<em>list</em>) – The list of integers (i.e q value) for which the q-gram
tokenizer must be generated (defaults to [2, 3]).</li>
<li><strong>dlm_char</strong> (<em>list</em>) – The list of characters (i.e delimiter character) for
which the delimiter tokenizer must be generated (defaults to [` ‘]).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Python dictionary with tokenizer name as the key and tokenizer
function as the value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If both <cite>q</cite> and <cite>dlm_char</cite> are set to None.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dlm_char</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dlm_char</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/adding_features"></span><div class="section" id="adding-features-to-feature-table">
<h4>Adding Features to Feature Table<a class="headerlink" href="#adding-features-to-feature-table" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="py_entitymatching.get_feature_fn">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_feature_fn</code><span class="sig-paren">(</span><em>feature_string</em>, <em>tokenizers</em>, <em>similarity_functions</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_feature_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a feature in a declarative manner.</p>
<p>Specifically, this function uses the feature string, parses it and
compiles it into a function using the given tokenizers and similarity
functions. This compiled function will take in two tuples and return a
feature value (typically a number).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>feature_string</strong> (<em>string</em>) – A feature expression
to be converted into a function.</li>
<li><strong>tokenizers</strong> (<em>dictionary</em>) – A Python dictionary containing tokenizers.
Specifically, the dictionary contains tokenizer names as keys and
tokenizer functions as values. The tokenizer function typically
takes in a string and returns a list of tokens.</li>
<li><strong>similarity_functions</strong> (<em>dictionary</em>) – A Python dictionary containing
similarity functions. Specifically, the dictionary contains
similarity function names as keys and similarity functions as
values. The similarity function typically
takes in a string or two lists of tokens and returns a number.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>This function returns a Python dictionary which contains sufficient
information (such as attributes, tokenizers, function code) to be added
to the feature table.</p>
<p>Specifically the Python dictionary contains the following keys:
‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’,
‘right_attr_tokenizer’, ‘simfunction’, ‘function’, and
‘function_source’.</p>
<p>For all the keys except the ‘function’ and ‘function_source’ the
value will be either a valid string (if the input feature string is
parsed correctly) or PARSE_EXP (if the parsing was not successful).
The ‘function’ will have a valid Python function as value,
and ‘function_source’ will have the Python function’s source in
string format.</p>
<p>The created function is a self-contained function
which means that the tokenizers and sim functions that it calls are
bundled along with the returned function code.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>feature_string</cite> is not of type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the input <cite>tokenizers</cite> is not of type
dictionary.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the input <cite>similarity_functions</cite> is not of
type dictionary.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.name), qgm_3(rtuple.name)&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.name), qgm_3(rtuple.name)&#39;</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">match_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="index.html#py_entitymatching.get_sim_funs_for_blocking" title="py_entitymatching.get_sim_funs_for_blocking"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_sim_funs_for_blocking()</span></code></a>,
<a class="reference internal" href="index.html#py_entitymatching.get_tokenizers_for_blocking" title="py_entitymatching.get_tokenizers_for_blocking"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_tokenizers_for_blocking()</span></code></a>,
<a class="reference internal" href="index.html#py_entitymatching.get_sim_funs_for_matching" title="py_entitymatching.get_sim_funs_for_matching"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code></a>,
<a class="reference internal" href="index.html#py_entitymatching.get_tokenizers_for_matching" title="py_entitymatching.get_tokenizers_for_matching"><code class="xref py py-meth docutils literal"><span class="pre">py_entitymatching.get_tokenizers_for_matching()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.add_feature">
<code class="descclassname">py_entitymatching.</code><code class="descname">add_feature</code><span class="sig-paren">(</span><em>feature_table</em>, <em>feature_name</em>, <em>feature_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.add_feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a feature to the feature table.</p>
<p>Specifically, this function is used in combination with
<a class="reference internal" href="#py_entitymatching.get_feature_fn" title="py_entitymatching.get_feature_fn"><code class="xref py py-meth docutils literal"><span class="pre">get_feature_fn()</span></code></a>.
First the user creates a dictionary using <a class="reference internal" href="#py_entitymatching.get_feature_fn" title="py_entitymatching.get_feature_fn"><code class="xref py py-meth docutils literal"><span class="pre">get_feature_fn()</span></code></a>,
then the user uses this function to add feature_dict to the feature table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing features.</li>
<li><strong>feature_name</strong> (<em>string</em>) – The name that should be given to the feature.</li>
<li><strong>feature_dict</strong> (<em>dictionary</em>) – A Python dictionary, that is typically
returned by executing <a class="reference internal" href="#py_entitymatching.get_feature_fn" title="py_entitymatching.get_feature_fn"><code class="xref py py-meth docutils literal"><span class="pre">get_feature_fn()</span></code></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned if the addition was successful.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the input <cite>feature_table</cite> is not of type
pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>feature_name</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>feature_dict</cite> is not of type
Python dictionary.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>feature_table</cite> does not have necessary columns
such as ‘feature_name’, ‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’,
‘right_attr_tokenizer’, ‘simfunction’, ‘function’, and
‘function_source’ in the DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>feature_name</cite> is already present in the feature
table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.name), qgm_3(rtuple.name)&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.name), qgm_3(rtuple.name)&#39;</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">match_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.add_blackbox_feature">
<code class="descclassname">py_entitymatching.</code><code class="descname">add_blackbox_feature</code><span class="sig-paren">(</span><em>feature_table</em>, <em>feature_name</em>, <em>feature_function</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.add_blackbox_feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a black box feature to the feature table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>feature_table</strong> (<em>DataFrame</em>) – The input DataFrame (typically a feature
table) to which the feature must be added.</li>
<li><strong>feature_name</strong> (<em>string</em>) – The name that should be given to the feature.</li>
<li><strong>feature_function</strong> (<em>Python function</em>) – A Python function for the black box
feature.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Boolean value of True is returned if the addition was successful.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the input <cite>feature_table</cite> is not of type
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the input <cite>feature_name</cite> is not of type
string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>feature_table</cite> does not have necessary columns
such as ‘feature_name’, ‘left_attribute’, ‘right_attribute’,
‘left_attr_tokenizer’,
‘right_attr_tokenizer’, ‘simfunction’, ‘function’, and
‘function_source’ in the DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>feature_name</cite> is already present in the
feature table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/extracting_feature_vectors"></span><div class="section" id="extracting-feature-vectors">
<h4>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="py_entitymatching.extract_feature_vecs">
<code class="descclassname">py_entitymatching.</code><code class="descname">extract_feature_vecs</code><span class="sig-paren">(</span><em>candset</em>, <em>attrs_before=None</em>, <em>feature_table=None</em>, <em>attrs_after=None</em>, <em>verbose=False</em>, <em>show_progress=True</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.extract_feature_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>This function extracts feature vectors from a DataFrame (typically a
labeled candidate set).</p>
<p>Specifically, this function uses feature
table, ltable and rtable (that is present in the <cite>candset</cite>’s
metadata) to extract feature vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>candset</strong> (<em>DataFrame</em>) – The input candidate set for which the features
vectors should be extracted.</li>
<li><strong>attrs_before</strong> (<em>list</em>) – The list of attributes from the input candset,
that should be added before the feature vectors (defaults to None).</li>
<li><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing a list of
features that should be used to compute the feature vectors (
defaults to None).</li>
<li><strong>attrs_after</strong> (<em>list</em>) – The list of attributes from the input candset
that should be added after the feature vectors (defaults to None).</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be displayed (defaults to False).</li>
<li><strong>show_progress</strong> (<em>boolean</em>) – A flag to indicate whether the progress of
extracting feature vectors must be displayed (defaults to True).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>A pandas DataFrame containing feature vectors.</p>
<p>The DataFrame will have metadata ltable and rtable, pointing
to the same ltable and rtable as the input candset.</p>
<p>Also, the output
DataFrame will have three columns: key, foreign key ltable, foreign
key rtable copied from input candset to the output DataFrame. These
three columns precede the columns mentioned in <cite>attrs_before</cite>.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>candset</cite> is not of type pandas
DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>attrs_before</cite> has attributes that
are not present in the input candset.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>attrs_after</cite> has attribtues that
are not present in the input candset.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>feature_table</cite> is set to None.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled dataframe which should be converted into feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feature_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_before</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">],</span> <span class="n">attrs_after</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/imputing_missing_values"></span><div class="section" id="imputing-missing-values">
<h4>Imputing Missing Values<a class="headerlink" href="#imputing-missing-values" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="py_entitymatching.impute_table">
<code class="descclassname">py_entitymatching.</code><code class="descname">impute_table</code><span class="sig-paren">(</span><em>table</em>, <em>exclude_attrs=None</em>, <em>missing_val=’NaN’</em>, <em>strategy=’mean’</em>, <em>axis=0</em>, <em>val_all_nans=0</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.impute_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Impute table containing missing values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>table</strong> (<em>DataFrame</em>) – DataFrame which values should be imputed.</li>
<li><strong>exclude_attrs</strong> (<em>List</em>) – list of attribute names to be excluded from
imputing (defaults to None).</li>
<li><strong>missing_val</strong> (<em>string</em><em> or </em><em>int</em>) – The placeholder for the missing values.
All occurrences of <cite>missing_values</cite> will be imputed.
For missing values encoded as np.nan, use the string value ‘NaN’
(defaults to ‘NaN’).</li>
<li><strong>strategy</strong> (<em>string</em>) – String that specifies on how to impute values. Valid
strings: ‘mean’, ‘median’, ‘most_frequent’ (defaults to ‘mean’).</li>
<li><strong>axis</strong> (<em>int</em>) – axis=1 along rows, and axis=0 along columns  (defaults
to 0).</li>
<li><strong>val_all_nans</strong> (<em>float</em>) – Value to fill in if all the values in the column
are NaN.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Imputed DataFrame.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>table</cite> is not of type pandas DataFrame.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># H is the feature vector which should be imputed. Specifically, impute the missing values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># in each column, with the mean of that column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">impute_table</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/supported_similarity_functions"></span><div class="section" id="supported-similarity-functions">
<h4>Supported Similarity Functions<a class="headerlink" href="#supported-similarity-functions" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="py_entitymatching.affine">
<code class="descclassname">py_entitymatching.</code><code class="descname">affine</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the affine measure between the two input strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s1</strong><strong>,</strong><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure
should be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The affine measure if both the strings are not missing (i.e NaN or
None), else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="s1">&#39;dva&#39;</span><span class="p">,</span> <span class="s1">&#39;deeva&#39;</span><span class="p">)</span>
<span class="go">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;deeva&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.hamming_dist">
<code class="descclassname">py_entitymatching.</code><code class="descname">hamming_dist</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.hamming_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Hamming distance between the two input
strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s1</strong><strong>,</strong><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Hamming distance if both the strings are not missing (i.e NaN),
else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">hamming_dist</span><span class="p">(</span><span class="s1">&#39;alex&#39;</span><span class="p">,</span> <span class="s1">&#39;john&#39;</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">hamming_dist</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;john&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.hamming_sim">
<code class="descclassname">py_entitymatching.</code><code class="descname">hamming_sim</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.hamming_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Hamming similarity between the two input
strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s1</strong><strong>,</strong><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Hamming similarity if both the strings are not missing (i.e NaN),
else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">hamming_sim</span><span class="p">(</span><span class="s1">&#39;alex&#39;</span><span class="p">,</span> <span class="s1">&#39;alxe&#39;</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">hamming_sim</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;alex&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.lev_dist">
<code class="descclassname">py_entitymatching.</code><code class="descname">lev_dist</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.lev_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Levenshtein distance between the two input
strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s1</strong><strong>,</strong><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Levenshtein distance if both the strings are not missing (i.e NaN),
else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">lev_dist</span><span class="p">(</span><span class="s1">&#39;alex&#39;</span><span class="p">,</span> <span class="s1">&#39;alxe&#39;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">lev_dist</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;alex&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.lev_sim">
<code class="descclassname">py_entitymatching.</code><code class="descname">lev_sim</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.lev_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Levenshtein similarity between the two input
strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s1</strong><strong>,</strong><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Levenshtein similarity if both the strings are not missing (i.e
NaN), else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">lev_sim</span><span class="p">(</span><span class="s1">&#39;alex&#39;</span><span class="p">,</span> <span class="s1">&#39;alxe&#39;</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">lev_dist</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;alex&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.jaro">
<code class="descclassname">py_entitymatching.</code><code class="descname">jaro</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.jaro" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Jaro measure between the two input
strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s1</strong><strong>,</strong><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Jaro measure if both the strings are not missing (i.e NaN),
else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaro</span><span class="p">(</span><span class="s1">&#39;MARTHA&#39;</span><span class="p">,</span> <span class="s1">&#39;MARHTA&#39;</span><span class="p">)</span>
<span class="go">0.9444444444444445</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaro</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;MARTHA&#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.jaro_winkler">
<code class="descclassname">py_entitymatching.</code><code class="descname">jaro_winkler</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.jaro_winkler" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Jaro Winkler measure between the two input
strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s1</strong><strong>,</strong><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Jaro Winkler measure if both the strings are not missing (i.e NaN),
else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaro_winkler</span><span class="p">(</span><span class="s1">&#39;MARTHA&#39;</span><span class="p">,</span> <span class="s1">&#39;MARHTA&#39;</span><span class="p">)</span>
<span class="go">0.9611111111111111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">&gt;&gt;&gt;</span> <span class="n">em</span><span class="o">.</span><span class="n">jaro_winkler</span><span class="p">(</span><span class="s1">&#39;MARTHA&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.needleman_wunsch">
<code class="descclassname">py_entitymatching.</code><code class="descname">needleman_wunsch</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.needleman_wunsch" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Needleman-Wunsch measure between the two input
strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s1</strong><strong>,</strong><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Needleman-Wunsch measure if both the strings are not missing (i.e
NaN), else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">needleman_wunsch</span><span class="p">(</span><span class="s1">&#39;dva&#39;</span><span class="p">,</span> <span class="s1">&#39;deeva&#39;</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">needleman_wunsch</span><span class="p">(</span><span class="s1">&#39;dva&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.smith_waterman">
<code class="descclassname">py_entitymatching.</code><code class="descname">smith_waterman</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.smith_waterman" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Smith-Waterman measure between the two input
strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s1</strong><strong>,</strong><strong>s2</strong> (<em>string</em>) – The input strings for which the similarity measure should
be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Smith-Waterman measure if both the strings are not missing (i.e
NaN), else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">smith_waterman</span><span class="p">(</span><span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="s1">&#39;hat&#39;</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">smith_waterman</span><span class="p">(</span><span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.jaccard">
<code class="descclassname">py_entitymatching.</code><code class="descname">jaccard</code><span class="sig-paren">(</span><em>arr1</em>, <em>arr2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.jaccard" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Jaccard measure between the two input
lists/sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr1</strong><strong>,</strong><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the Jaccard
measure should be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Jaccard measure if both the lists/set are not None and do not have
any missing tokens (i.e NaN), else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaccard</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">jaccard</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.cosine">
<code class="descclassname">py_entitymatching.</code><code class="descname">cosine</code><span class="sig-paren">(</span><em>arr1</em>, <em>arr2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.cosine" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the cosine measure between the two input
lists/sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr1</strong><strong>,</strong><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the cosine
measure should be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The cosine measure if both the lists/set are not None and do not have
any missing tokens (i.e NaN), else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">cosine</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
<span class="go">0.7071067811865475</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">cosine</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.overlap_coeff">
<code class="descclassname">py_entitymatching.</code><code class="descname">overlap_coeff</code><span class="sig-paren">(</span><em>arr1</em>, <em>arr2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.overlap_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the overlap coefficient between the two input
lists/sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr1</strong><strong>,</strong><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input lists or sets for which the overlap
coefficient should be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The overlap coefficient if both the lists/sets are not None and do not
have any missing tokens (i.e NaN), else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">overlap_coeff</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">overlap_coeff</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.dice">
<code class="descclassname">py_entitymatching.</code><code class="descname">dice</code><span class="sig-paren">(</span><em>arr1</em>, <em>arr2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.dice" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Dice score between the two input
lists/sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr1</strong><strong>,</strong><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the Dice
score should be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Dice score if both the lists/set are not None and do not
have any missing tokens (i.e NaN), else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">dice</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
<span class="go">0.6666666666666666</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">dice</span><span class="p">([</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;science&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.monge_elkan">
<code class="descclassname">py_entitymatching.</code><code class="descname">monge_elkan</code><span class="sig-paren">(</span><em>arr1</em>, <em>arr2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.monge_elkan" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the Monge-Elkan measure between the two input
lists/sets. Specifically, this function uses Jaro-Winkler measure as the
secondary function to compute the similarity score.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arr1</strong><strong>,</strong><strong>arr2</strong> (<em>list</em><em> or </em><em>set</em>) – The input list or sets for which the
Monge-Elkan measure should be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The Monge-Elkan measure if both the lists/set are not None and do not
have any missing tokens (i.e NaN), else  returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">monge_elkan</span><span class="p">([</span><span class="s1">&#39;Niall&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Neal&#39;</span><span class="p">])</span>
<span class="go">0.8049999999999999</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">monge_elkan</span><span class="p">([</span><span class="s1">&#39;Niall&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.exact_match">
<code class="descclassname">py_entitymatching.</code><code class="descname">exact_match</code><span class="sig-paren">(</span><em>d1</em>, <em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.exact_match" title="Permalink to this definition">¶</a></dt>
<dd><p>This function check if two objects are match exactly. Typically the
objects are string, boolean and ints.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>d1</strong><strong>,</strong><strong>d2</strong> (<em>str</em><em>, </em><em>boolean</em><em>, </em><em>int</em>) – The input objects which should checked
whether they match exactly.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A value of 1 is returned if they match exactly,
else returns 0. Further if one of the objects is NaN or None,
it returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="s1">&#39;Niall&#39;</span><span class="p">,</span> <span class="s1">&#39;Neal&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="s1">&#39;Niall&#39;</span><span class="p">,</span> <span class="s1">&#39;Niall&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">exact_match</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.rel_diff">
<code class="descclassname">py_entitymatching.</code><code class="descname">rel_diff</code><span class="sig-paren">(</span><em>d1</em>, <em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.rel_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the relative difference between two numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>d1</strong><strong>,</strong><strong>d2</strong> (<em>float</em>) – The input numbers for which the relative difference
must be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A float value of relative difference between the input numbers (if
they are valid). Further if one of the input objects is NaN or None,
it returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">rel_diff</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="go">0.6666666666666666</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">rel_diff</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">rel_diff</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.abs_norm">
<code class="descclassname">py_entitymatching.</code><code class="descname">abs_norm</code><span class="sig-paren">(</span><em>d1</em>, <em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.abs_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the absolute norm similarity between two numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>d1</strong><strong>,</strong><strong>d2</strong> (<em>float</em>) – Input numbers for which the absolute norm must
be computed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A float value of absolute norm between the input numbers (if
they are valid). Further if one of the input objects is NaN or None,
it returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">abs_norm</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">abs_norm</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">abs_norm</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/supported_tokenizers"></span><div class="section" id="supported-tokenizers">
<h4>Supported Tokenizers<a class="headerlink" href="#supported-tokenizers" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="py_entitymatching.tok_qgram">
<code class="descclassname">py_entitymatching.</code><code class="descname">tok_qgram</code><span class="sig-paren">(</span><em>input_string</em>, <em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.tok_qgram" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits the input string into a list of q-grams. Note that,
by default the input strings are padded and then tokenized.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</li>
<li><strong>q</strong> (<em>int</em>) – q-val that should be used to tokenize the input string.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of tokens, if the input string is not NaN,
else returns NaN.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_qgram</span><span class="p">(</span><span class="s1">&#39;database&#39;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[&#39;#d&#39;, &#39;da&#39;, &#39;at&#39;, &#39;ta&#39;, &#39;ab&#39;, &#39;ba&#39;, &#39;as&#39;, &#39;se&#39;, &#39;e$&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_qgram</span><span class="p">(</span><span class="s1">&#39;database&#39;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[&#39;##d&#39;, &#39;#da&#39;, &#39;dat&#39;, &#39;ata&#39;, &#39;tab&#39;, &#39;aba&#39;, &#39;bas&#39;, &#39;ase&#39;, &#39;se$&#39;, &#39;e$$&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_qgram</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.tok_delim">
<code class="descclassname">py_entitymatching.</code><code class="descname">tok_delim</code><span class="sig-paren">(</span><em>input_string</em>, <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.tok_delim" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits the input string into a list of tokens
(based on the delimiter).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</li>
<li><strong>d</strong> (<em>string</em>) – Delimiter string.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of tokens, if the input string is not NaN ,
else returns NaN.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_delim</span><span class="p">(</span><span class="s1">&#39;data science&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_delim</span><span class="p">(</span><span class="s1">&#39;data$#$science&#39;</span><span class="p">,</span> <span class="s1">&#39;$#$&#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_delim</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.tok_wspace">
<code class="descclassname">py_entitymatching.</code><code class="descname">tok_wspace</code><span class="sig-paren">(</span><em>input_string</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.tok_wspace" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits the input string into a list of tokens
(based on the white space).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of tokens, if the input string is not NaN ,
else returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_wspace</span><span class="p">(</span><span class="s1">&#39;data science&#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_wspace</span><span class="p">(</span><span class="s1">&#39;data         science&#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_wspace</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.tok_alphabetic">
<code class="descclassname">py_entitymatching.</code><code class="descname">tok_alphabetic</code><span class="sig-paren">(</span><em>input_string</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.tok_alphabetic" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of tokens that are maximal sequences of
consecutive alphabetical characters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of tokens, if the input string is not NaN ,
else returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphabetic</span><span class="p">(</span><span class="s1">&#39;data99science, data#integration.&#39;</span><span class="p">)</span>
<span class="go">[&#39;data&#39;, &#39;science&#39;, &#39;data&#39;, &#39;integration&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphabetic</span><span class="p">(</span><span class="s1">&#39;99&#39;</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphabetic</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.tok_alphanumeric">
<code class="descclassname">py_entitymatching.</code><code class="descname">tok_alphanumeric</code><span class="sig-paren">(</span><em>input_string</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.tok_alphanumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a list of tokens that are maximal sequences of
consecutive alphanumeric characters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>input_string</strong> (<em>string</em>) – Input string that should be tokenized.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of tokens, if the input string is not NaN ,
else returns NaN.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphanumeric</span><span class="p">(</span><span class="s1">&#39;data9,(science), data9#.(integration).88&#39;</span><span class="p">)</span>
<span class="go">[&#39;data9&#39;, &#39;science&#39;, &#39;data9&#39;, &#39;integration&#39;, &#39;88&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphanumeric</span><span class="p">(</span><span class="s1">&#39;#.$&#39;</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">tok_alphanumeric</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
<span id="document-user_manual/api/matching"></span><div class="section" id="matching">
<h3>Matching<a class="headerlink" href="#matching" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/splitting_data_into_train_test"></span><div class="section" id="splitting-data-into-train-and-test">
<h4>Splitting Data into Train and Test<a class="headerlink" href="#splitting-data-into-train-and-test" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="py_entitymatching.split_train_test">
<code class="descclassname">py_entitymatching.</code><code class="descname">split_train_test</code><span class="sig-paren">(</span><em>labeled_data</em>, <em>train_proportion=0.5</em>, <em>random_state=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.split_train_test" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits the input data into train and test.</p>
<p>Specifically, this function is just a wrapper of scikit-learn’s
train_test_split function.</p>
<p>This function also takes care of copying the metadata from the input
table to train and test splits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>labeled_data</strong> (<em>DataFrame</em>) – The input pandas DataFrame that needs to be
split into train and test.</li>
<li><strong>train_proportion</strong> (<em>float</em>) – A number between 0 and 1, indicating the
proportion of tuples that should be included in the train split (
defaults to 0.5).</li>
<li><strong>random_state</strong> (<em>object</em>) – A number of random number object (as in
scikit-learn).</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be displayed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A Python dictionary containing two keys - train and test.</p>
<p>The value for the key ‘train’ is a pandas DataFrame containing tuples
allocated from the input table based on train_proportion.</p>
<p>Similarly, the value for the key ‘test’ is a pandas DataFrame containing
tuples for evaluation.</p>
<p>This function sets the output DataFrames (train, test) properties
same as the input DataFrame.</p>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data or the feature vectors that should be split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">train_proportion</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/supported_matchers"></span><div class="section" id="supported-matchers">
<h4>Supported Matchers<a class="headerlink" href="#supported-matchers" title="Permalink to this headline">¶</a></h4>
<div class="section" id="ml-matchers">
<h5>ML Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="py_entitymatching.DTMatcher">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">DTMatcher</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.DTMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Decision Tree matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*args</strong><strong>,</strong><strong>**kwargs</strong> – The arguments to scikit-learn’s Decision Tree
classifier.</li>
<li><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For more details please see</p>
<dl class="method">
<dt id="py_entitymatching.DTMatcher.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.DTMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</li>
<li><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.DTMatcher.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>x=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em>, <em>append=False</em>, <em>return_probs=False</em>, <em>probs_attr=None</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.DTMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</li>
<li><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</li>
<li><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</li>
<li><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</li>
<li><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</li>
<li><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array of predictions or a DataFrame with predictions updated.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.RFMatcher">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">RFMatcher</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RFMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Random Forest matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*args</strong><strong>,</strong><strong>**kwargs</strong> – The arguments to scikit-learn’s Random Forest
classifier.</li>
<li><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="py_entitymatching.RFMatcher.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RFMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</li>
<li><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.RFMatcher.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>x=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em>, <em>append=False</em>, <em>return_probs=False</em>, <em>probs_attr=None</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.RFMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</li>
<li><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</li>
<li><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</li>
<li><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</li>
<li><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</li>
<li><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array of predictions or a DataFrame with predictions updated.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.SVMMatcher">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">SVMMatcher</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SVMMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>SVM matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*args</strong><strong>,</strong><strong>**kwargs</strong> – The arguments to scikit-learn’s SVM
classifier.</li>
<li><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="py_entitymatching.SVMMatcher.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SVMMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</li>
<li><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.SVMMatcher.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>x=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em>, <em>append=False</em>, <em>return_probs=False</em>, <em>probs_attr=None</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.SVMMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</li>
<li><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</li>
<li><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</li>
<li><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</li>
<li><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</li>
<li><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array of predictions or a DataFrame with predictions updated.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.NBMatcher">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">NBMatcher</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.NBMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Naive Bayes matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*args</strong><strong>,</strong><strong>**kwargs</strong> – The arguments to scikit-learn’s Naive Bayes
classifier.</li>
<li><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="py_entitymatching.NBMatcher.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.NBMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</li>
<li><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.NBMatcher.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>x=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em>, <em>append=False</em>, <em>return_probs=False</em>, <em>probs_attr=None</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.NBMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</li>
<li><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</li>
<li><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</li>
<li><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</li>
<li><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</li>
<li><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array of predictions or a DataFrame with predictions updated.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.LinRegMatcher">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">LinRegMatcher</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LinRegMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear regression matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*args</strong><strong>,</strong><strong>**kwargs</strong> – Arguments to scikit-learn’s Linear Regression matcher.</li>
<li><strong>name</strong> (<em>string</em>) – Name that should be given to this matcher.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="py_entitymatching.LinRegMatcher.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LinRegMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</li>
<li><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.LinRegMatcher.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>x=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em>, <em>append=False</em>, <em>return_probs=False</em>, <em>probs_attr=None</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LinRegMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</li>
<li><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</li>
<li><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</li>
<li><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</li>
<li><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</li>
<li><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array of predictions or a DataFrame with predictions updated.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.LogRegMatcher">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">LogRegMatcher</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LogRegMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Logistic Regression matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*args</strong><strong>,</strong><strong>**kwargs</strong> – THe Arguments to scikit-learn’s Logistic Regression
classifier.</li>
<li><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="py_entitymatching.LogRegMatcher.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LogRegMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</li>
<li><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.LogRegMatcher.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>x=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em>, <em>append=False</em>, <em>return_probs=False</em>, <em>probs_attr=None</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.LogRegMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</li>
<li><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</li>
<li><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</li>
<li><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</li>
<li><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</li>
<li><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array of predictions or a DataFrame with predictions updated.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="py_entitymatching.XGBoostMatcher">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">XGBoostMatcher</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.XGBoostMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>XGBoost matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*args</strong><strong>,</strong><strong>**kwargs</strong> – The arguments to XGBoost
classifier.</li>
<li><strong>name</strong> (<em>string</em>) – The name of this matcher (defaults to None). If the
matcher name is None, the class automatically generates a string
and assigns it as the name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="py_entitymatching.XGBoostMatcher.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>x=None</em>, <em>y=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.XGBoostMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the fit method.
First, interface similar to scikit-learn where the feature vectors
and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute.</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input feature vectors given as pandas
DataFrame (defaults to None).</li>
<li><strong>y</strong> (<em>DatFrame</em>) – The input target attribute given as pandas
DataFrame with a single column (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.XGBoostMatcher.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>x=None</em>, <em>table=None</em>, <em>exclude_attrs=None</em>, <em>target_attr=None</em>, <em>append=False</em>, <em>return_probs=False</em>, <em>probs_attr=None</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.XGBoostMatcher.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict interface for the matcher.</p>
<p>Specifically, there are two ways the user can call the predict method.
First, interface similar to scikit-learn where the feature vectors
given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) .</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing only feature
vectors (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing feature
vectors, and may be other attributes (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – A list of attributes to be excluded from the
input table to get the feature vectors (defaults to None).</li>
<li><strong>target_attr</strong> (<em>string</em>) – The attribute name where the predictions
need to be stored in the input table (defaults to None).</li>
<li><strong>probs_attr</strong> (<em>string</em>) – The attribute name where the prediction probabilities
need to be stored in the input table (defaults to None).</li>
<li><strong>append</strong> (<em>boolean</em>) – A flag to indicate whether the predictions need
to be appended in the input DataFrame (defaults to False).</li>
<li><strong>return_probs</strong> (<em>boolean</em>) – A flag to indicate where the prediction probabilities
need to be returned (defaults to False). If set to True, returns the
probability if the pair was a match.</li>
<li><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array of predictions or a DataFrame with predictions updated.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="rule-based-matcher">
<h5>Rule-Based Matcher<a class="headerlink" href="#rule-based-matcher" title="Permalink to this headline">¶</a></h5>
<blockquote>
<div></div></blockquote>
</div>
</div>
<span id="document-user_manual/api/selecting_matcher"></span><div class="section" id="selecting-matcher">
<h4>Selecting Matcher<a class="headerlink" href="#selecting-matcher" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="py_entitymatching.select_matcher">
<code class="descclassname">py_entitymatching.</code><code class="descname">select_matcher</code><span class="sig-paren">(</span><em>matchers, x=None, y=None, table=None, exclude_attrs=None, target_attr=None, metric_to_select_matcher=’precision’, metrics_to_display=[‘precision’, ‘recall’, ‘f1’], k=5, n_jobs=-1, random_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.select_matcher" title="Permalink to this definition">¶</a></dt>
<dd><p>This function selects a matcher from a given list of matchers based on a
given metric.</p>
<p>Specifically, this function internally uses scikit-learn’s
cross validation function to select a matcher. There are two ways the
user can call the fit method. First, interface similar to scikit-learn
where the feature vectors and target attribute given as projected DataFrame.
Second, give the DataFrame and explicitly specify the feature vectors
(by specifying the attributes to be excluded) and the target attribute</p>
<p>A point to note is all the input parameters have a default value of
None. This is done to support both the interfaces in a single function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>matchers</strong> (<em>MLMatcher</em>) – List of ML matchers to be selected from.</li>
<li><strong>x</strong> (<em>DataFrame</em>) – Input feature vectors given as pandas DataFrame (
defaults to None).</li>
<li><strong>y</strong> (<em>DatFrame</em>) – Input target attribute given as pandas
DataFrame with a single column (defaults to None).</li>
<li><strong>table</strong> (<em>DataFrame</em>) – Input pandas DataFrame containing feature
vectors and target attribute (defaults to None).</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes that should be
excluded from the input table to get the feature vectors.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The target attribute in the input table (defaults
to None).</li>
<li><strong>metric_to_select_matcher</strong> (<em>string</em>) – The metric based on which the matchers must be
selected. The string can be one of ‘precision’, ‘recall’,
‘f1’ (defaults to ‘precision’).</li>
<li><strong>metrics_to_display</strong> (<em>list</em>) – The metrics that will be displayed to
the user. It should be a list of any of the strings ‘precision’,
‘recall’, or ‘f1’ (defaults to [‘precision’, ‘recall’, ‘f1’]).</li>
<li><strong>k</strong> (<em>int</em>) – The k value for cross-validation (defaults to 5).</li>
<li><strong>n_jobs</strong> (<em>integer</em>) – The number of CPUs to use to do the computation.
-1 means ‘all CPUs (defaults to -1)’.</li>
<li><strong>random_state</strong> (<em>object</em>) – Pseudo random number generator that should be
used for splitting the data into folds (defaults to None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A dictionary containing three keys - selected matcher, cv_stats, and drill_down_cv_stats.</p>
<blockquote>
<div><p>The selected matcher has a value that is a matcher (MLMatcher) object,
cv_stats is a Dataframe containing average metrics for each matcher,
and drill_down_cv_stats is a dictionary containing a table for each metric
the user wants to display containing the score of the matchers for each fold.</p>
</div></blockquote>
<dl class="docutils">
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>AssertionError: If <cite>metric_to_select_matcher</cite> is not one of ‘precision’, ‘recall’,</dt>
<dd><p class="first last">or ‘f1’.</p>
</dd>
<dt>AssertionError: If each item in the list <cite>metrics_to_display</cite> is not one of</dt>
<dd><p class="first last">’precision’, ‘recall’, or ‘f1’.</p>
</dd>
</dl>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="go"># train is the feature vector containing user labels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">select_matcher</span><span class="p">(</span><span class="n">matchers</span><span class="o">=</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="n">rf</span><span class="p">],</span> <span class="n">table</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
<span id="document-user_manual/api/debugging_matcher"></span><div class="section" id="debugging-matcher">
<h3>Debugging Matcher<a class="headerlink" href="#debugging-matcher" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.vis_debug_dt">
<code class="descclassname">py_entitymatching.</code><code class="descname">vis_debug_dt</code><span class="sig-paren">(</span><em>matcher</em>, <em>train</em>, <em>test</em>, <em>exclude_attrs</em>, <em>target_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.vis_debug_dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Visual debugger for Decision Tree matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>matcher</strong> (<a class="reference internal" href="index.html#py_entitymatching.DTMatcher" title="py_entitymatching.DTMatcher"><em>DTMatcher</em></a>) – The Decision tree matcher that should be debugged.</li>
<li><strong>train</strong> (<em>DataFrame</em>) – The pandas DataFrame that will be used to train the
matcher.</li>
<li><strong>test</strong> (<em>DataFrame</em>) – The pandas DataFrame that will be used to test the
matcher.</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes to be excluded from train
and test, for training and testing.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The attribute name in the ‘train’ containing the
true labels.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="go"># &#39;devel&#39; is the labeled set used for development (e.g., selecting the best matcher) purposes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">vis_debug_dt</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.vis_debug_rf">
<code class="descclassname">py_entitymatching.</code><code class="descname">vis_debug_rf</code><span class="sig-paren">(</span><em>matcher</em>, <em>train</em>, <em>test</em>, <em>exclude_attrs</em>, <em>target_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.vis_debug_rf" title="Permalink to this definition">¶</a></dt>
<dd><p>Visual debugger for Random Forest matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>matcher</strong> (<a class="reference internal" href="index.html#py_entitymatching.RFMatcher" title="py_entitymatching.RFMatcher"><em>RFMatcher</em></a>) – The Random Forest matcher that should be debugged.</li>
<li><strong>train</strong> (<em>DataFrame</em>) – The pandas DataFrame that will be used to train the
matcher.</li>
<li><strong>test</strong> (<em>DataFrame</em>) – The pandas DataFrame that will be used to test the
matcher.</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – The list of attributes to be excluded from train
and test, for training and testing.</li>
<li><strong>target_attr</strong> (<em>string</em>) – The attribute name in the ‘train’ containing the
true labels.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="go"># &#39;devel&#39; is the labeled set used for development (e.g., selecting the best matcher) purposes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">vis_debug_rf</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.debug_decisiontree_matcher">
<code class="descclassname">py_entitymatching.</code><code class="descname">debug_decisiontree_matcher</code><span class="sig-paren">(</span><em>decision_tree</em>, <em>tuple_1</em>, <em>tuple_2</em>, <em>feature_table</em>, <em>table_columns</em>, <em>exclude_attrs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.debug_decisiontree_matcher" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to debug a decision tree matcher using two input
tuples.</p>
<p>Specifically, this function takes in two tuples, gets the feature vector
using the feature table and finally passes it to the decision tree and
displays the path that the feature vector takes in the decision tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>decision_tree</strong> (<a class="reference internal" href="index.html#py_entitymatching.DTMatcher" title="py_entitymatching.DTMatcher"><em>DTMatcher</em></a>) – The input
decision tree object that should be debugged.</li>
<li><strong>tuple_1</strong><strong>,</strong><strong>tuple_2</strong> (<em>Series</em>) – Input tuples that should be debugged.</li>
<li><strong>feature_table</strong> (<em>DataFrame</em>) – Feature table containing the functions
for the features.</li>
<li><strong>table_columns</strong> (<em>list</em>) – List of all columns that will be outputted
after generation of feature vectors.</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – List of attributes that should be removed from
the table columns.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the input feature table is not of type pandas
DataFrame.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># devel is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># F is the feature vector got from evaluation set of the labeled data.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A and B are input tables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">debug_decisiontree_matcher</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">match_f</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.debug_randomforest_matcher">
<code class="descclassname">py_entitymatching.</code><code class="descname">debug_randomforest_matcher</code><span class="sig-paren">(</span><em>random_forest</em>, <em>tuple_1</em>, <em>tuple_2</em>, <em>feature_table</em>, <em>table_columns</em>, <em>exclude_attrs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.debug_randomforest_matcher" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to debug a random forest matcher using two input
tuples.</p>
<p>Specifically, this function takes in two tuples, gets the feature vector
using the feature table and finally passes it to the random forest  and
displays the path that the feature vector takes in each of the decision
trees that make up the random forest matcher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>random_forest</strong> (<a class="reference internal" href="index.html#py_entitymatching.RFMatcher" title="py_entitymatching.RFMatcher"><em>RFMatcher</em></a>) – The input
random forest object that should be debugged.</li>
<li><strong>tuple_1</strong><strong>,</strong><strong>tuple_2</strong> (<em>Series</em>) – Input tuples that should be debugged.</li>
<li><strong>feature_table</strong> (<em>DataFrame</em>) – Feature table containing the functions
for the features.</li>
<li><strong>table_columns</strong> (<em>list</em>) – List of all columns that will be outputted
after generation of feature vectors.</li>
<li><strong>exclude_attrs</strong> (<em>list</em>) – List of attributes that should be removed from
the table columns.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the input feature table is not of type pandas
DataFrame.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># devel is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># F is the feature vector got from evaluation set of the labeled data.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># A and B are input tables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">debug_randomforest_matcher</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">match_f</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span id="document-user_manual/api/triggers"></span><div class="section" id="triggers">
<h3>Triggers<a class="headerlink" href="#triggers" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="py_entitymatching.MatchTrigger">
<em class="property">class </em><code class="descclassname">py_entitymatching.</code><code class="descname">MatchTrigger</code><a class="headerlink" href="#py_entitymatching.MatchTrigger" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="py_entitymatching.MatchTrigger.add_action">
<code class="descname">add_action</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.MatchTrigger.add_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an action to the match trigger. If the result of a rule is the
same value as the condition status, then the action will be carried
out. The condition status can be added with the function add_cond_status.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd>value (integer): The action. Currently only the values 0 and 1 are supported.</dd>
<dt>Examples:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_status</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_action</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.MatchTrigger.add_cond_rule">
<code class="descname">add_cond_rule</code><span class="sig-paren">(</span><em>conjunct_list</em>, <em>feature_table</em>, <em>rule_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.MatchTrigger.add_cond_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a rule to the match trigger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>conjunct_list</strong> (<em>list</em>) – A list of conjuncts specifying the rule.</li>
<li><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing all the
features that are being referenced by
the rule (defaults to None). If the
feature_table is not supplied here,
then it must have been specified
during the creation of the rule-based
blocker or using set_feature_table
function. Otherwise an AssertionError
will be raised and the rule will not
be added to the rule-based blocker.</li>
<li><strong>rule_name</strong> (<em>string</em>) – A string specifying the name of the rule to
be added (defaults to None). If the
rule_name is not specified then a name will
be automatically chosen. If there is already
a rule with the specified rule_name, then
an AssertionError will be raised and the
rule will not be added to the rule-based
blocker.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The name of the rule added (string).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>rule_name</cite> already exists.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>feature_table</cite> is not a valid value parameter.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.MatchTrigger.add_cond_status">
<code class="descname">add_cond_status</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.MatchTrigger.add_cond_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a condition status to the match trigger. If the result of a rule
is the same value as the condition status, then the action will be
carried out. The action can be added with the function add_action.</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd>status (boolean): The condition status.</dd>
<dt>Examples:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_status</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_action</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.MatchTrigger.delete_rule">
<code class="descname">delete_rule</code><span class="sig-paren">(</span><em>rule_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.MatchTrigger.delete_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a rule from the match trigger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be deleted.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.MatchTrigger.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>input_table</em>, <em>label_column</em>, <em>inplace=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.MatchTrigger.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the rules of the match trigger for a table of matcher
results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_table</strong> (<em>DataFrame</em>) – The input table of type pandas DataFrame
containing tuple pairs and labels from matching (defaults to None).</li>
<li><strong>label_column</strong> (<em>string</em>) – The attribute name where the predictions
are stored in the input table (defaults to None).</li>
<li><strong>inplace</strong> (<em>boolean</em>) – A flag to indicate whether the append needs to be
done inplace (defaults to True).</li>
<li><strong>verbose</strong> (<em>boolean</em>) – A flag to indicate whether the debug information
should be logged (defaults to False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A DataFrame with predictions updated.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_status</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_action</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The table H is a table with prediction labels generated from matching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input_table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.MatchTrigger.get_rule">
<code class="descname">get_rule</code><span class="sig-paren">(</span><em>rule_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.MatchTrigger.get_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the function corresponding to a rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rule_name</strong> (<em>string</em>) – Name of the rule.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A function object corresponding to the specified rule.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">get_rule</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.MatchTrigger.get_rule_names">
<code class="descname">get_rule_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.MatchTrigger.get_rule_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all the rules in the match trigger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of names of all the rules in the match trigger (list).</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.MatchTrigger.set_feature_table">
<code class="descname">set_feature_table</code><span class="sig-paren">(</span><em>feature_table</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.MatchTrigger.set_feature_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets feature table for the match trigger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>feature_table</strong> (<em>DataFrame</em>) – A DataFrame containing features.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">set_feature_table</span><span class="p">(</span><span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="py_entitymatching.MatchTrigger.view_rule">
<code class="descname">view_rule</code><span class="sig-paren">(</span><em>rule_name</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.MatchTrigger.view_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the source code of the function corresponding to a rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rule_name</strong> (<em>string</em>) – Name of the rule to be viewed.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title_title_lev_sim(ltuple, rtuple) &gt; 0.7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<span id="document-user_manual/api/evaluating_the_matching_output"></span><div class="section" id="evaluating-the-matching-output">
<h3>Evaluating the Matching Output<a class="headerlink" href="#evaluating-the-matching-output" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="py_entitymatching.eval_matches">
<code class="descclassname">py_entitymatching.</code><code class="descname">eval_matches</code><span class="sig-paren">(</span><em>data_frame</em>, <em>gold_label_attr</em>, <em>predicted_label_attr</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.eval_matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the matches from the matcher.</p>
<p>Specifically, given a DataFrame containing golden labels and predicted
labels, this function would evaluate the matches and return the accuracy
results such as precision, recall and F1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_frame</strong> (<em>DataFrame</em>) – The input pandas DataFrame containing “gold”
labels and “predicted” labels.</li>
<li><strong>gold_label_attr</strong> (<em>string</em>) – An attribute in the input DataFrame containing
“gold” labels.</li>
<li><strong>predicted_label_attr</strong> (<em>string</em>) – An attribute in the input DataFrame
containing “predicted” labels.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Python dictionary containing the accuracy measures such as
precision, recall, F1.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>data_frame</cite> is not of type
pandas DataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>gold_label_attr</cite> is not of
type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If <cite>predicted_label_attr</cite> is not of
type string.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>gold_label_attr</cite> is not in
the input dataFrame.</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code> – If the <cite>predicted_label_attr</cite> is not in
the input dataFrame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.print_eval_summary">
<code class="descclassname">py_entitymatching.</code><code class="descname">print_eval_summary</code><span class="sig-paren">(</span><em>eval_summary</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.print_eval_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a summary of evaluation results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>eval_summary</strong> (<em>dictionary</em>) – Dictionary containing evaluation results,
typically from ‘eval_matches’ function.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">print_eval_summary</span><span class="p">(</span><span class="n">eval_summary</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_false_positives_as_df">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_false_positives_as_df</code><span class="sig-paren">(</span><em>table</em>, <em>eval_summary</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_false_positives_as_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Select only the false positives from the input table and return as a
DataFrame based on the evaluation results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>table</strong> (<em>DataFrame</em>) – The input table (pandas DataFrame) that was used for
evaluation.</li>
<li><strong>eval_summary</strong> (<em>dictionary</em>) – A Python dictionary containing evaluation
results, typically from ‘eval_matches’ command.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A pandas DataFrame containing only the False positives from
the input table.</p>
<p>Further,
this function sets the output DataFrame’s properties same as input
DataFrame.</p>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_pos_df</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_false_positives_as_df</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">eval_summary</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="py_entitymatching.get_false_negatives_as_df">
<code class="descclassname">py_entitymatching.</code><code class="descname">get_false_negatives_as_df</code><span class="sig-paren">(</span><em>table</em>, <em>eval_summary</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#py_entitymatching.get_false_negatives_as_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Select only the false negatives from the input table and return as a
DataFrame based on the evaluation results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>table</strong> (<em>DataFrame</em>) – The input table (pandas DataFrame) that was used for
evaluation.</li>
<li><strong>eval_summary</strong> (<em>dictionary</em>) – A Python dictionary containing evaluation
results, typically from ‘eval_matches’ command.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A pandas DataFrame containing only the false negatives from
the input table.</p>
<p>Further,
this function sets the output DataFrame’s properties same as input
DataFrame.</p>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G is the labeled data used for development purposes, match_f is the feature table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false_neg_df</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_false_negatives_as_df</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">eval_summary</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


                    </div>
                </div>
            </div>

            
            <div class="clearer"></div>
        </div>
    </div>
</div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">py_entitymatching 0.3.0 documentation</a> &#187;</li> 
      </ul>
    </div>
<style type="text/css">
    .scrollToTop {
        text-align: center;
        font-weight: bold;
        position: fixed;
        bottom: 60px;
        right: 40px;
        display: none;
    }
</style>
<a href="#" class="scrollToTop">Scroll To Top</a>
<script type="text/javascript">
$(document).ready(function() {
    //Check to see if the window is top if not then display button
    $(window).scroll(function() {
        if ($(this).scrollTop() > 200) {
            $('.scrollToTop').fadeIn();
        } else {
            $('.scrollToTop').fadeOut();
        }
    });

    //Click event to scroll to top
    $('.scrollToTop').click(function() {
        $('html, body').animate({
            scrollTop: 0
        }, 500);
        return false;
    });
});
</script>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27880019-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>